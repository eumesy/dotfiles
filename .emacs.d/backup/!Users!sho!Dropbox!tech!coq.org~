* ref
言語仕様
http://coq.inria.fr/documentation
名古屋大学 講義資料 2013年度前期・数理解析・計算機数学 II
http://www.math.nagoya-u.ac.jp/~garrigue/lecture/2013_SS/
ProofCafe - 名古屋を中心に活動する定理証明器・関数型言語のコミュニティ
http://www.proofcafe.org/index.html
ProofCafe - Front Page
http://proofcafe.org/wiki/
fm-forum @ ウィキ - Coq参考資料
http://www39.atwiki.jp/fm-forum/pages/17.html
Coq 20100208a
http://www.slideshare.net/tmiya/coq-20100208a
参考文献あり p.9

* 実行環境
** install
*** Coq 8.4
$ brew install coq
むちゃくちゃ時間かかる (built 19min) ...そんなでもないかな

*** CoqIDE
CoqIdE_8.4pl2 Mac OS X 10.8で動かない?
http://www.lix.polytechnique.fr/coq/bugs/show_bug.cgi?id=3072
http://www.lix.polytechnique.fr/coq/bugs/show_bug.cgi?id=3063

8.3なら動く模様 Download -> 8.3(画面下)
*** ProofGeneral
http://proofgeneral.inf.ed.ac.uk/ から頑張る?

** coqtop
終了は C-d

** Proof General (Emacs)
C-c C-n
  Next Step
C-c C-u   
  Undo
C-c C-RET   proof-goto-print
  カーソル位置まで処理を進める（戻す） #使えない…
C-c C-p
  証明すべき命題（ゴール）を表示
C-c C-t
  既になされた証明・定義を表示

ProofCafe - ProofGeneral - よく使うキーバインド
  http://proofcafe.org/wiki/ProofGeneral
ProofCafe - ProofGeneral/Keybinds
  http://proofcafe.org/wiki/ProofGeneral/Keybinds

** coqc hoge.v (コンパイル)
  
* 教科書
ソフトウェアの基礎(beta) — ソフトウェアの基礎 1.0.2 documentation
http://proofcafe.org/sf-beta/

* 文法
statement の終わり「.」

** 制御
if then else
コンストラクタが2つの inductive type なら使える

** 型の定義
  Inductive
  
  再帰的定義はコンストラクタで

  関数とコンストラクタ 同じ nat -> nat 型だが
    コンストラクタ
    ・記号を付与するだけ
    ・パターンマッチできる
  
    関数
    ・計算できる
    ・パターンマッチできない

** 多相型
コンストラクタをコンストラクタとして利用 -> 型を引数として明示する必要がある
コンストラクタをmatch構文で利用 -> 型を引数として明示する必要はない

** 関数の定義 Definition/Fixpoint
  Definition
  Fixpoint (再帰的関数の場合)

  match * with
  | ...
  end.

  - 網羅的である事はチェックされる
  - 重複は許される模様
  - 一部の冗長はハネられる（過去のケースに包含される場合？）
  
  match n, m with // 複数変数まとめてmatch可
    O, _ => 

** 式の計算 Eval ( simpl | compute )
  Eval simpl in ().
  ・simpl or compute

** 型チェック Check
  Check hoge.

** 言明と証明
  気分で使い分ける
  人間が、それをどれくらい偉いと思っているか
  exampleで「任意の」とかは言わない、とか

  Example
  Theorem
  Lemma
  Fact
  Remark

  Theorem theorem_name: 命題.
  「:」左は右の証明になっている。それをいまから書く
  → theorem_name is defined. // 証明終わり

  Proof.
  [TACTICS]
  Qed.
  # 証明できると、hoge is deinde と出る
  Abort. 中止?
  
* tactic
** reflexivity.
   反射律
   「= の両辺は等しい。よって題意は示された」
   n * m = n * m は通る
   同じ式の形なら通る?
   簡約できない事は無い??
   forall n:nat, * = * みたいなのは通る?

** simpl. / simpl in H.
   simplify 簡約する
   simplification 単純化
   Definition で定義された関数の計算をすすめてくれない
   
** unfold.
   Definition で定義された関数を展開してくれる
    
** compute.
   compute の方が simpl よりも計算を積極的に進めてくれる一方、関数定義なども積極的に展開してしまうので、結果が巨大になってかえってわかりずらくなってしまうことがある
  
** intros. (全称量化子を仮定へ)
  intros n. 型だけ仮定した変数を仮定におく？
  intros H. // -> の左辺を仮定とおく

** generalize dependent n. (仮定を全称量化へ)
文脈で(に?)仮定した変数を再び全称量子する

** apply H. / apply L in H. (ならばの利用)
*** apply H.
ゴールを導くための前提条件に遡る

- 使いたい式: 「forall ならば」
H: forall x, P1(x) -> ... -> Pn(x) -> Q(x)
目標: Q(k)

apply H.

目標: P1(k), ... , Pn(k)

- 使いたい式: 等式
そのまま適用
# 前件なしの場合?

*** apply L in H.
L: P->Q
H: P
---
Q

# modus ponens?

- apply H. は後向き推論
  十分条件へ遡る
  H: L1->L2
  goal: L2
  ---
  goal: L1
  
- apply L in H は前向き推論
  既知の事実や仮定から新しい判断を得る
  L: L1->L2
  H: L1
  ---
  H: L2

** apply ... with ... . 
どこに適用すれば良いのか教える
e.g. apply trans_eq with (m:=[c;d])
   
** symmetry. / symmetry in H.
結論辺々入れ替え

** rewrite. / rewrite ... in H.
rewrite -> H. // 仮定Hの左辺→右辺を用いて書き換え
rewrite -> hogehoge. 過去に証明した定理（全称量化子を使ったものね？）でも書き換えOK
  
** 場合分けは | を連続させず、スペースをあける?
** destruct n as [|n']. (場合分け)
#+BEGIN_SRC coq
destruct n as [|n']
#+END_SRC

   - （仮定に上がっている変数の？）具体的な形を考えると計算が進む場合がある
   - 場合分けとは限らない（2引数コンストラクタ）
     # ???
   - '|' の間には *コンストラクタの引数* を書く
     - 2引数のコンストラクタなら2つ
    無ければ略記可 [|] でも [] でもOK

** induction n as [|n']. (数学的帰納法)
induction n as [|n']
数学的帰納法

** inversion H. (単射性の利用、矛盾の規則の利用)
コンストラクタの単射性を利用

(i) コンストラクタが一致している場合、中身が等しい事を帰結
H: S n = S m
-> inversion H
-> n = m

さらに、生成できた一連の式で結論をrewrite -> してくれる

(ii) コンストラクタが不一致の場合、ゴールは解消
前件が偽なのでどんな結論でも言える
# 矛盾の規則
# 背理法?

** destruct EXP. / destruct EXP eqn:Heqe1. (EXPの評価による場合分け)
EXPの評価結果による場合分け
eqn:~ でEXPの評価結果を文脈に保存可

** assert
assertion 主張
補題

assert (H: n + m = m + n).

** Case  
Case "n = 0"

** SearchAbout
SearchAbout hoge.
既に評価済みの/過去に定義した関数、定理から、全文検索?
ProofGeneral C-c C-a C-a

* Module
隠蔽
  Module Hoge.
  End Hoge.
  
  作ったブツは Hoge.moga でアクセスできる

記法
  Notation

---
関数の一致
・中身が全く同じ ← こちらを判定する??
・同じインプットには同じアウトプット
