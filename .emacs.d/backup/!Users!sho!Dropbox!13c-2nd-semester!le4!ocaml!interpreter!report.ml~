(* Ex.3.1 *)

(*
 * [実行例]
 * 
 * ./miniml
 * # iv + iii * ii;;
 * iv + iii * ii;;
 * val - = 10
 *
 * 期待通り動作することが確認できた。
 *)


(******************************************************)
(* Ex.3.3 *)

(*
 * [説明]
 *
 * && と || はともに右結合的であり、
 * 結合の強さは、* (強) * + > && || (弱) である。
 * ref. http://caml.inria.fr/pub/docs/manual-ocaml-4.01/expr.html
 *
 *
 * [実行例]
 *
 * ＜結合の強さの確認＞
 * 
 * # 1 < 2 && true;;
 * 1 < 2 && true;;
 * val - = true
 * 
 * # true && 1 < 2;;
 * true && 1 < 2;;
 * val - = true
 *
 * →  && よりも < が強い。
 * （弱ければ「&&の引数はともにbool値の必要あり」というエラーが返る筈）
 *
 * 
 * # true || false && false;;
 * true || false && false;;
 * val - = true
 * 
 * # false && false || true;;
 * false && false || true;;
 * val - = true
 *
 * → || よりも && が強い。
 * （弱ければ false が返る筈）
 *
 *
 * ＜右結合性の確認＞
 * eval.ml に debug_mode というグローバル変数を用意し、
 * これが true のとき、apply_exp の実行結果をプリントするようにした。
 *
 * # true && true && false && false;;
 * true && true && false && false;;
 * false
 * false
 * false
 * val - = false
 * 
 * 確かに右結合的であることが分かる。
 *)


(******************************************************)
(* Ex.3.4 *)

(*
 * [実行例]
 *
 * ＜let宣言の例＞
 * # let y = 20;;
 * let y = 20;;
 * val y = 20
 * 
 * # x + y;;
 * x + y;;
 * val - = 30
 *
 * ＜let式の例＞
 * # let z = 3 in x + z;;
 * let z = 3 in x + z;;
 * val - = 13
 * ※ xは大域変数として10が格納されている。
 *
 * 期待通り動作していることが分かる。
 *)


(******************************************************)
(* Ex.3.8 *)

(*
 * [実行例]
 *
 * ＜関数閉包の生成＞
 * # let square = fun x -> x * x;;
 * let square = fun x -> x * x;;
 * val square = <fun>
 * 
 *
 * ＜関数適用＞
 * # square 3;;
 * square 3;;
 * val - = 9
 *
 * 
 * ＜高階関数 ... 関数を引数とする関数＞
 * # let apply_two = fun f -> f 2;;
 * let apply_two = fun f -> f 2;;
 * val apply_two = <fun>
 *
 * # apply_two square;;
 * apply_two square;;
 * val - = 4
 * 
 *
 * ＜高階関数 ... 関数を返り値とする関数＞
 * # let double = fun f -> (fun x -> f (f x));;
 * let double = fun f -> (fun x -> f (f x));;
 * val double = <fun>
 *
 * # let fourth_power = double square;;
 * let fourth_power = double square;;
 * val fourth_power = <fun>
 * 
 * # fourth_power 2;;
 * fourth_power 2;;
 * val - = 16
 *
 * いずれも期待通り動作している事が分かる。
 *)

(******************************************************)
(* Ex.3.14 *)

(*
 * [説明]
 * ProcV コンストラクタの第3引数が、環境から環境への参照となった事に伴い、
 * ProcV の利用および生成をしているコード部に修正をおこなった。
 *
 * また、lec ret 宣言は、評価時に
 * eval_decl により環境の更新（変数にProcVを紐付けて追加）のみをすれば良い。
 *
 *
 * [実行例]
 * 階乗を計算する関数f作成した。
 * 
 * パラメータとしても、大域変数として定義済みの変数「x」を利用しているが、
 * 環境が正しく上書きされていることが分かる。
 * 
 * - let rec 文
 * # let rec f = fun x -> if x < 1 then 1 else x * f (x + (-1)) in f 5;;
 * val - = 120
 *
 * - let rec 宣言
 * # let rec f = fun x -> if x < 1 then 1 else x * f (x + (-1));;
 * val f = <fun>
 * # f 5;;
 * val - = 120
 *)
