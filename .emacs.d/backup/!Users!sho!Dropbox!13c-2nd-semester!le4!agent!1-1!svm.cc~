#include <iostream>
#include <stdio.h>
#include <sstream>
#include <string>
#include "QuadProg++.hh"

#define MAX_NUM_DATA MATRIX_DIM // 学習データ数の上限 = MATRIX_DIM

// hogehogehogehoge

int main(int argc, char *const argv[])
{
  int num = 0;
  int i, j, k, l;

  // 学習データの読込み
  int x1[MAX_NUM_DATA] ,x2[MAX_NUM_DATA] ,y[MAX_NUM_DATA];
  while(scanf("%d %d %d",&x1[num],&x2[num],&y[num])!=EOF) {
  	num++;
  }
  
  // 2次計画問題
  double G[MATRIX_DIM][MATRIX_DIM], g0[MATRIX_DIM], 
	CE[MATRIX_DIM][MATRIX_DIM], ce0[MATRIX_DIM], 
	CI[MATRIX_DIM][MATRIX_DIM], ci0[MATRIX_DIM], 
	x[MATRIX_DIM];
  int n; // 未知数(Lagrange乗数)の次元, 学習データの数
  int m; // 制約条件(等式)の本数
  int p; // 制約条件(不等式)の本数
  double sum = 0.0;
  char ch;
  
  n = num; // 未知数(Lagrange乗数)の次元, 学習データの数
  // G
  for (i = 0; i < n; i++)	{
	for (j = 0; j < n; j++) {
	  // 内積
	  G[i][j] = y[i] * y[j] * (x1[i] * x1[j] + x2[i] * x2[j]);
	}
  }

  // g0
  for (int i = 0; i < n; i++)
	g0[i] = -1.0;

  m = 1; // 制約条件(等式)の本数
  // CE
  for (i = 0; i < n; i++) {
	for (j = 0; j < m; j++) {
	  CE[i][j] = y[i];
	}
  }
  // ce0
  for (j = 0; j < m; j++)
	ce0[j] = 0.0;
  
  p = 100; // 制約条件(不等式)の本数
  // CI
  for (int i = 0; i < n; i++) {
	for (int j = 0; j < p; j++) {
	  if (i == j) CI[i][j] = 1.0;
	  else  CI[i][j] = 0.0;
	}
  }
  // ci0
  for (int j = 0; j < p; j++)
	ci0[j] = 0.0;


  
  std::cout << "f: " << solve_quadprog(G, g0, n, CE, ce0, m, CI, ci0, p, x) << std::endl;
  std::cout << "x: ";
  
  for (int i = 0; i < n; i++)
	std::cout << x[i] << ' ';
  std::cout << std::endl;	

  	/* FOR DOUBLE CHECKING COST since in the solve_quadprog routine the matrix G is modified */
	
	{
    std::istringstream is("4, -2,"
													"-2, 4 ");
	
		for (int i = 0; i < n; i++)
			for (int j = 0; j < n; j++)
				is >> G[i][j] >> ch;
	}
	
	for (int i = 0; i < n; i++)
		for (int j = 0; j < n; j++)
			sum += x[i] * G[i][j] * x[j];
	sum *= 0.5;
	
	std::cout << "Double checking cost: ";
	for (int i = 0; i < n; i++)
		sum += g0[i] * x[i];
	std::cout << sum << std::endl;


  for (i = 0; i < n; i++)	{
	for (j = 0; j < n; j++) {
	  // 内積
	  printf("%f ", G[i][j]);
	  puts("");
	}
  }
	  

	return 0;
}
