* 131022 1 Basics 前半 <コメント欄>
[質問]
Fixpoint で再帰的関数を定義する際、(decreasing in nth argument) とメッセージが出ます。
これについて、講義中「第n引数がどんどん"減って"」いると説明がありましたが、これは、
「コンストラクタが外れていく」という意味で合っていますか？
＝型定義において、コンストラクタは常に付与する（増やす）もの、という認識で良いでしょうか？
[感想]
翌週のレジュメを配布して頂くのは、予習に取り組みやすく、ありがたいです。

* 131022 2 Basics 後半、Induction <質問票>

* 131029 2 Basics 後半、Induction <コメント欄>
evenb （Oに向けて再帰していく事で偶数判定） は、計算量的に、とても「使える」ものに見えません。
再帰の練習として用いているだけなのでしょうか。
それとも、プログラムの「証明可能性」と「高速性」は、ある意味でトレードオフなのでしょうか。

* 131112 3 Lists <コメント欄>
hd_opt で、match によって引数の l:natlist を場合分けする際、「(1)h::t (2)Nil」の順で場合分けすると定義できるのですが、「(1)Nil (2)h::t」の順で場合分けすると redundant だと怒られます。これはどういう事なのでしょうか。

* 131119 4 Poly <コメント欄>
- combine の逆関数(?) split を作る際、局所的な再期関数 body を用意しました。強引な気がしますし、想定されていた解のようにも思えません。想定されていた解法がどのようなものであったか教えて頂きたいです。
- 型パラメータ「forall X : Type,」について、引数のように型を与える場合と与えない場合の違いはどこにあるのでしょうか。下のふたつのケースの違いをどう捉えれば良いのかが分かりません。
  - コンストラクタをコンストラクタとして扱う場合は型を引数のように持たせる必要があるが e.g.「nil nat」
  - match でコンストラクタによるパターンマッチする場合は型を引数のように持たせてはならない e.g.「× nil X」

* 131203 5 MoreCoq <コメント欄>
- レジュメその5のp.22「自然数について再び」は以下のように捉えれば良いですか？
  - 1番目の項は、自然数を生成するコンストラクタ全体(?)の全射性
  - 2番目の項は、機能的に定義されたコンストラクタの単射性
  - 2番目の項と3番目の項を合わせて、コンストラクタ全体(?)の単射性
- 結局、Inductiveで定義できるような適切な(?)型定義は全単射であるという話でしょうか？
- これは、ラムダ計算において「項が一意に簡約できること(合流性＋前進性 ?)」に対応する概念ということでしょうか…？
* 140107 6 Logic.v <コメント欄>
- eq_refl は、(=I)規則(reflexivity)を使う際の M_1 <--> M_2 を示す論理式、すなわち公理となっているように見えます。
  - 実際にはこの上に簡約規則が積み上がるように思われるのですが、簡約規則(計算)が証明木(論理)の中に入っているのはどのように捉えれば良いのでしょうか。特に、証明木全体を、カリー-ハワード同型対応でラムダ項と見なそうとするとき、「証明木を表すラムダ項」と「証明木の中に組み込まれたラムダ項」を同じように見てよいのか、それとも別の階層にあると捉えるべきなのかが分かりません。
- Logic.v で論理結合子を生成するとき、結局 -> に帰着しているように思われます。単純型付きラムダ計算と同型対応を取りたい直観主義論理の体系を自然演繹で記述するとき、「->」と「forall」があれば実は十分で、我々が分かりやすいように「/\」や「\/」を導入しているのでしょうか。つまり、「/\」や「\/」は syntax sugar に過ぎないのでしょうか。
  - 同様に、直積や直和も、「-> (写像?)」をプリミティブ(?)とした syntax sugar に過ぎないのでしょうか。
    ===>(20140121 口頭) その通り -> と forall ですべて(?)


* 140114 7 Prop.v <コメント欄>
- 新しい論理結合子や述語を用意する際、導入則のみを用意し除去則は用意されていないように見えるのですが、自然演繹の除去則は一般に導入則から導かれる(?)のでしょうか。
  ===>(20140121 口頭) Inductive を定義する際、自動的に除去則が設定される
                      nat を定義するだけで数学的帰納法が整えられるように
# - Theorem beautiful__gorgeous : forall n, beautiful n -> gorgeous n.
#  の証明をする際、既に仮定に持ち上げておいた B: beautiful n について induction で場合分けを行いました。ここで、 beautiful の4番目のコンストラクタは 
# b_sum : forall n m, beautiful n -> beautiful m -> beautiful (n+m). 
# という形をしており、induction において必要な引数(変数および帰納法の仮定)は4つ(n, m, beautiful n, beautiful m)かと思われたのですが、実際には6つ(左記＋gorgeous n, gorgeours m)必要でした。
# なぜ、結論側の「gorgeours 
# 元の命題の段階で場合分けを行ったのであれば、

* 質問 ストック
** 1 Basics 前半
・簡約で証明 簡約は一意？
・Eval simpl in (next_weekday (next_weekday saturday)). (* 関数評価も関数そのものも記法同じ? *)
(*引数を書いたら関数適用? *)
・simpl compute違い気になる
・nat、元々あるものを更に上書きしている？
・evenb （レジュメ p.57）とても「使える」ものには見えない
  練習として使っているだけ？
  それとも、プログラミング言語の「証明可能」と「高速」はトレードオフ？
・Notationのnat_scopeなに？
・講義の裏テーマ 証明＝プログラム 触れて欲しい

** 2 Basics 後半
intros は、**定理のこと？
・Case "n = 0"より =O の方が良い気が
・plus_O、plus_0 気持ち悪い…

intros n. 型だけ仮定した変数を仮定におく？

-> を使う対象は決められないの?

** Induction
これは背理法??
  false = true, b = false -> b = true

・〜定理？

・過去二つとか、過去全部を引き継ぐ帰納法は無い??

** Lists
hd_opt
  Nilを後から出さないとredunduntになるのは何事…

帰納法＝好きにコンストラクタを付けてよい の証明 (in Coq) ということ？

nonzeros_app、0だからnで場合分けできたけれど、そうでない場合分けは？
いちいち新しい型を用意しないといけない？

- natoption 使っても、結局受取り手が場合分けするのだよね
  Null Pointer に対してどういうメリットがあるのだろう

** Poly
- なぜ check list. は forall 付かない?
- nil の引数?
  - nil nat とは何?
  - fixpoint length
  - レジュメ p.13
- "X" にしなきゃいけない?
- 証明中で match のような場合分けはできない?

- nil
     : forall X : Type, list X <-これ何????
  分からん...

length の match でも nil/cons 単体で使ってるのだよね...
-> これはtype入れると怒られる

nil nat は nat 必要

e  grumble true型?!

** MoreCoq
- (3)問題(... n_n ...)、過度に難しく解いている気がする...
解答例、ないし、よりシンプルな例があれば見たい

- length_snoc' の証明中の f_equal と、 inversion は何が違うのか

** Logic.v
- Coqにおいては、型付きλ計算っぽく（簡約で）考えるときも、

- 単純型付きラムダ計算のレジュメ terms ::= S ??
- ラムダ項より命題の方が階層が高いように見える












* ほか
- 関数 x->y->z と x/\y ->z の違いは?
  ===>(20140121 口頭) 1引数か2引数かの違いはあるけれど、結局/\は->->のシンタックスシュガーだし、本質的には同じ(?)
