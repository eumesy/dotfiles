■配列変数とポインタ変数
http://homepage3.nifty.com/mmgames/c_guide/15-07.html
  配列はあくまでも多数の変数の先頭を示す固定された変数であり、
  ポインタ変数は、好きな変数のアドレスを代入して、好きなメモリ領域を使うことが出来る可変的な変数です。

Head First C
  char s[] = "hogehoge";
  char *t = s;
  
  &s == s
  &t != t

  配列変数はメモリに格納されない
  配列変数への参照は、コンパイル時に配列のアドレスに置き換えられる


■[]演算子
- a[n]

  配列のn番目の要素の値
  a[n] := *(a+n)


宣言
・型 変数名[サイズ]

・indexは0はじまり
・indexが有効範囲かコンパイラはチェックしない
  ・エラーは"Segmentation fault"
    ・↑ポインタの問題？

・[サイズ]に変数は入れられない?

・多次元配列
  ・y[12][31] // y[31]が12個
    ★←こちら向きに「何が、何個で、かける何個で…」と考える

初期化
int i[5] = {1,4,9,16,25};

★文字列の初期化
ヌル文字を入れない場合
char[3] = {'A','B','C'};
入れる場合
char[5] = "Herb";
★文字列定数が使われると、コンパイラが自動でヌル文字を追加する
  ↑文字列定数＝ヌル文字付き文字入り配列？

多次元配列の初期化
int sqr[3][3] = {
  {1,2,3},
  {4,5,6},
  {7,8,9}
};
[3][3]
↑ ↑
↑ 列 横幅
行 高さ

★2次元配列の引数渡し: 日々此精進
http://murakan.cocolog-nifty.com/blog/2011/08/cc-b731.html



★一次元配列の初期化には、そもそも次元の指定が不要
・unsized array
int pwr[] = {1,2,4,8,16};
char prompt[] = "Enter your name: ";

★多次元配列は、左端のみできる
int sqr[][3] = {
  {1,2,3},
  {4,5,6},
  {7,8,9}
};
・メリット：配列の次元を変更せずに、テーブルを長くしたり短くしたりできる

■ポインタ

・ポインタ演算子：*, &
・*の意味
  ・ポインタ変数の宣言
  ・ポインタ変数が指すオブジェクトの値

・ポインタ変数
  ・★ポインタとは、別のオブジェクトのアドレスを保持する変数
  ・int *p;
    ・「別のオブジェクト」はint型
    ・int型オブジェクトのアドレスを格納できる
    ・型：ポインタの基本データ型
    ・一般にCコンパイラはポインタの指すオブジェクトが何バイトであるのかを基本データ型から判断する
    
    ・int* pとか int * pについて
        http://www.atmarkit.co.jp/ait/articles/1208/08/news133.html
  ・p = &q;
    ・q(int型)のアドレスを格納した
    ・★&hoge : hogeのアドレス
    ・hoge : 一次元配列hogeの先頭のアドレス。「配列名を使って生成されたポインタ」
      ・これはインクリメント(＝変数の中身の変更)できない。常に配列の先頭を指す定数
      ・★★添字なしの配列名で生成されたポインタの値を変更することはできないech
      ・*(hoge+3) とかはできる→6.9.c
      ・p = strとかして、p++ したあとに printf("%s", p)すると、pの2文字目から語末までが表示される むむむ
    ・多次元配列の先頭のアドレスを指したい場合は型キャスト要→独習C p.165
    ・★p[i] : 一次元配列を指すポインタ が指す一次元配列の中身
  ・printf("%d", *p);
    ・ポインタを使ってqの値を表示
    ・★*hoge : ポインタhogeが指すオブジェクトの値

  ・ポインタ変数に適用できる演算子
    ・*
    ・&
    ・+, ++, -, --
      ・整数のみを足したり引いたりできる
    ・★インクリメント/デクリメントすると、基本データ型に従って「次のオブジェクト」を指す
      ・charは1バイトなので、常識的な挙動をする
    ・★+1 は ++ と等価
    ・ポインタ - ポインタ = その間に含まれる「要素の数」

  ・*p++ : *(p++)
  ・(*p)++ // pが指すオブジェクトの値をインクリメントしたいならこう
  ・★★*p++ = // *pに対して処理をしたあとpをインクリメント

・連結リストやバイナリツリーをサポートするために使われる

・printfの%pで、ポインタに格納されているメモリアドレスの値が分かる

・ポインタを配列に格納することもできるが、ポイント演算(?)の方が便利なのであまり行われない
  あまり使われない

□配列とポインタ
・添字を付けずに配列名だけを使うと、配列の先頭を指すポインタが生成される
  ・配列を「まるまる(?)」関数に渡すことはできない
・★★「配列を指すポインタは」、添字を付ける事ができる

http://www.geocities.jp/kuronishi_kakiteru/C/c_31.html


■構造体(Structure),構造体タグ,メンバ --
typedef struct h {
} *hoge;

typedef
  http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1254746057
  使うときに struct h でなくて、 hoge で済むようになる

*
  〜を指すポインタ型の変数を定義
  http://www.ced.is.utsunomiya-u.ac.jp/lecture/2011/prog/p2/kadai2/typedef.php

□宣言
struct 構造体タグ {
  int id;
  char name[20];
  ...
}; // セミコロン付ける

・構造体タグは変数名ではない
・メンバ：id,nameなど
・idという変数が定義されているわけではない
    × int id = 10;

□定義
struct student taro;
型名：「struct student」

□-- 定義+初期化
struct student taro = {10, "Yamada", …};
構造体の配列の初期化
struct student data[3] = {
  {20, "Suzuki", …},
  {11, …},
  … ★最後まで「,」打ってOK!!なんと。ref.結城本
}

□代入
taro.id = 2; // ポインタでない変数の場合
tarop->id = 2; // ポインタ変数の場合

jiro = taro;
同じ型であれば、まるまるコピーできる

□参照
taro.id