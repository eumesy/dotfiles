%{
open Syntax
%}

%token LPAREN RPAREN SEMISEMI
%token PLUS MULT LT
%token AND OR /* Ex.3.3 */
%token IF THEN ELSE TRUE FALSE
%token LET IN EQ /* Ex.3.4 let */
%token RARROW FUN /* Ex.3.8 fun */
%token REC /* Ex.3.14 let rec */

%token <int> INTV
%token <Syntax.id> ID

%start toplevel
%type <Syntax.program> toplevel
%%

toplevel :
   Expr SEMISEMI { Exp $1 }
 | LET ID EQ Expr SEMISEMI { Decl ($2, $4) } /* Ex.3.4 let宣言 */
 | LET REC ID EQ FUN ID RARROW Expr SEMISEMI { RecDecl ($3, $6, $8) } /* Ex.3.14 let rec宣言 */

Expr :
   IfExpr { $1 }
 | LetRecExp { $1 } /* Ex.3.14 let rec式 */
 | LetExpr { $1 } /* Ex.3.4 let式 */
 | FunExpr { $1 } /* Ex.3.8 関数値 */
 | ORExpr { $1 }

IfExpr :
    IF Expr THEN Expr ELSE Expr { IfExp ($2, $4, $6) }

LetRecExp : /* Ex.3.14 let rec式 */
    LET REC ID EQ FUN ID RARROW Expr IN Expr { LetRecExp ($3, $6, $8 ,$10) }

LetExpr : /* Ex.3.4 let式 */
    LET ID EQ Expr IN Expr { LetExp ($2, $4, $6) }

FunExpr :
   FUN ID RARROW Expr { FunExp ($2, $4) }
    
ORExpr : /* Ex.3.3 */
    ANDExpr OR ORExpr { BinOp (Or, $1, $3) }
  | ANDExpr { $1 }

ANDExpr : /* Ex.3.3 */
    LTExpr AND ANDExpr { BinOp (And, $1, $3) }
  | LTExpr { $1 }

LTExpr : 
    PExpr LT PExpr { BinOp (Lt, $1, $3) }
  | PExpr { $1 }

PExpr : /* (+) */
    PExpr PLUS MExpr { BinOp (Plus, $1, $3) }
  | MExpr { $1 }

MExpr : /* ( * ) */
    MExpr MULT AppExpr { BinOp (Mult, $1, $3) }
  | AppExpr { $1 }

AppExpr : /* Ex.3.8 Apply */
    AppExpr AExpr { AppExp ($1, $2) }
  | AExpr { $1 }

AExpr :
    INTV { ILit $1 }
  | TRUE { BLit true }
  | FALSE { BLit false }
  | ID { Var $1 }
  | LPAREN Expr RPAREN { $2 }


   
