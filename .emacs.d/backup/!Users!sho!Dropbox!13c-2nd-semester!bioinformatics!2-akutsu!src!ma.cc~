#include <iostream>
#include <string>
#include <vector>
#include <algorithm> // std::max
#include <limits> // std::numeric_limits

#define SEQ_MAX_LEN (100)
#define SEQ_MAX_NUM (50)

// score
class Score {
public:
  static const int same = 1;
  static const int diff = -1;
  static const int gap_cost = -1;
};

// 案内木
struct tree {
  int node_number;
  int fst_child;
  int snd_child;
};

using namespace std;

// global alignment
enum need_traceback {NEED_TB, DONT_NEED_TB};
int glob_align(string &a_in, string &b_in, string &a_out, string &b_out,
			   enum need_traceback nb);
void traceback(int (&D)[SEQ_MAX_LEN+1][SEQ_MAX_LEN+1], string &a_in, string &b_in,
			   int i, int j, string &a, string &b);

// 
// calc_distance(int (&d_score)[SEQ_MAX_NUM][SEQ_MAX_NUM]);

int main(int argc, char *argv[]) {
  // sequences
  vector<string> seq;
  seq.push_back("ACCGA");
  seq.push_back("ACGAT");
  seq.push_back("CCAGAT");
  seq.push_back("CGAAT");

  const int num_of_seq = (int)(seq.size());

  int seq_max_len = 0;
  for (int i=0; i<num_of_seq; i++)
	seq_max_len = max(seq_max_len, (int)(seq[i].size()));

  // similarity score
  int s_score[SEQ_MAX_NUM][SEQ_MAX_NUM];
  int s_max = Score::same * seq_max_len;
  int s_min =  100000;
  int s_range;
  string dummy_str1, dummy_str2;
  
  for (int i=0; i<num_of_seq; i++) {
	for (int j=0; j<num_of_seq; j++) {
	  if (j == i)
		continue;
	  else if (j > i) {
		s_score[i][j] = glob_align(seq[i], seq[j], dummy_str1, dummy_str2, DONT_NEED_TB);
		s_min = min(s_min, s_score[i][j]);
	  }
	  else // j < i
		s_score[i][j] = s_score[j][i];
	}
  }
  s_range = s_max - s_min;

  // distance
  double d_score[SEQ_MAX_NUM][SEQ_MAX_NUM];
  for (int i=0; i<num_of_seq; i++) {
	for (int j=0; j<num_of_seq; j++) {
	  if (j == i)
		continue;
	  else if (j > i)
		d_score[i][j] = 1.0 - ((s_score[i][j] - s_min) / (double)s_range);
	  else // j < i
		d_score[i][j] = d_score[j][i];
	}
  }

  // 近隣結合法
  int max_node_id = num_of_seq - 1; // ノード全体 = {0, ..., max_node_id}
  vector<int> L; // 集合Lに入っているノードの集合
  for (int i=0; i<num_of_seq; i++)
	L.push_back(i);

  // D
  double _D[SEQ_MAX_NUM][SEQ_MAX_NUM];
  double _D_min;
  int _node_fst_minimize_D;
  int _node_snd_minimize_D;
  
  // r
  double _r[SEQ_MAX_NUM];
    
  //  while (L.size() > 2) {
	// calc r
	for (int i=0; i<L.size(); i++) {
	  _r[i] = 0;
	  for (int k=0; k<L.size(); k++) {
		_r[i] += d_score[i][k];
	  }
	  _r[i] = _r[i] / (L.size() - 2);
	}

	// calc D
	_D_min = numeric_limits<double>::max();
	for (int i=0; i<L.size(); i++) {
	  for (int j=0; j<L.size(); j++) {
		if (j == i)
		  continue;
		else if (j > i) {
		  _D[i][j] = d_score[i][j] - _r[i] - _r[j];
		  if (_D[i][j] < _D_min) {
			_D_min = _D[i][j];
			_node_fst_minimize_D = i;
			_node_snd_minimize_D = j;
		  }
		}
		else // j < i
		  _D[i][j] = _D[j][i];
	  }
	}

	// create new node: _k
	max_node_id++;
	int _k = max_node_id;
	int _i = _node_fst_minimize_D;
	int _j = _node_snd_minimize_D;
	for (vector<int>::iterator it = L.begin(); it != L.end(); it++) {
	  int _m = *it;
	  if (_m == _i || _m == _j)
		continue;
	  d_score[_k][_m] = (d_score[_i][_m] + d_score[_j][_m] - d_score[_i][_j]) / 2.0;
	  d_score[_m][_k] = d_score[_k][_m];
	}
	// ★kとi,jを枝で結び
	d_score[_i][_k] = (d_score[_i][_j] + _r[i] - _r[j]) / 2.0;
	d_score[_k][_i] = d_score[_i][_k];
	d_score[_j][_k] = d[_i][_j] - d[_i][_k];
	
	for (int i=0; i<L.size(); i++) {
	  int _m = L[i];
	  if (_m == _i || _m == _j)
		continue;
	  d_score[_k][_m] = (d_score[_i][_m] + d_score[_j][_m] - d_score[_i][_j]);
	}

	L.push_back(_k);
	
	//  }

  for (int i=0; i<num_of_seq; i++) {
	for (int j=0; j<num_of_seq; j++) {
	  if (i == j)
		cout << "- ";
	  else
		cout << d_score[i][j] << " ";
	}
	cout << endl;
  }


  string a_in = "CCAGAT";
  string b_in = "ACGAT";
  string a_out;
  string b_out;
    
  glob_align(a_in, b_in, a_out, b_out, NEED_TB);
  cout << a_out << endl;
  cout << b_out << endl;

  return 0;
}

// global alignment
// return value: similarity score
int glob_align(string &a_in, string &b_in, string &a_out, string &b_out,
			   enum need_traceback nb) {
  int D[SEQ_MAX_LEN + 1][SEQ_MAX_LEN + 1];
  int i_max = a_in.size();
  int j_max = b_in.size();

  for (int i=0; i<=i_max; i++)
	D[i][0] = i * Score::gap_cost;
  
  for (int j=1; j<=j_max; j++)
	D[0][j] = j * Score::gap_cost;
  
  for (int i=1; i<=i_max; i++) {
	for (int j=1; j<=j_max; j++) {
	  D[i][j] =  max(max(D[i-1][j] + Score::gap_cost,
						 D[i][j-1] + Score::gap_cost),
					 D[i-1][j-1] + (a_in[i-1] == b_in[j-1] ? Score::same : Score::diff));
	}
  }

  if (nb == NEED_TB)
	traceback(D, a_in, b_in, i_max, j_max, a_out, b_out);
  
  return D[i_max][j_max];
}

void traceback(int (&D)[SEQ_MAX_LEN+1][SEQ_MAX_LEN+1], string &a_in, string &b_in,
			   int i, int j, string &a, string &b) {
  
  if (i == 0 && j == 0) {
	reverse(a.begin(), a.end());
	reverse(b.begin(), b.end());
	return;
  }
  else if (j == 0) { // →
	a += a_in[i-1];
	b += '-';
	traceback(D, a_in, b_in, i-1, j, a, b);
  }
  else if (i == 0) { // ↓
	a += '-';
	b += b_in[j-1];
	traceback(D, a_in, b_in, i, j-1, a, b);
  }
  else {
	if (D[i][j] == D[i-1][j] + Score::gap_cost) { // →
	  a += a_in[i-1];
	  b += '-';
	  traceback(D, a_in, b_in, i-1, j, a, b);
	}
	else if (D[i][j] == D[i][j-1] + Score::gap_cost) { // ↓
	  a += '-';
	  b += b_in[j-1];
	  traceback(D, a_in, b_in, i, j-1, a, b);
	}
	else { // D[i-1][j-1] + (a_in[i-1] == b_in[j-1] ? Score::same : Score::diff)
	  a += a_in[i-1];
	  b += b_in[j-1];
	  traceback(D, a_in, b_in, i-1, j-1, a, b);
	}
  }
}

// - 2 1 -1
// 2 - 2 2
// 1 2 - 2
// -1 2 2 -

// - 0.571429 0.714286 1
// 0.571429 - 0.571429 0.571429
// 0.714286 0.571429 - 0.571429
// 1 0.571429 0.571429 -
