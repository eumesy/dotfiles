(* 6.8 *)

type 'a tree = Lf | Br of 'a * 'a tree * 'a tree;;

let rec mem t x =
  match t with
  | Lf -> false
  | Br (y, left, right) ->
    if x = y then (
      true
    )
    else if x < y then (
      mem left x 
    )
    else (
      mem right x
    );;

let rec add t x =
  match t with
  | Lf -> Br (x, Lf, Lf) (* add x *)
  | (Br (y, left, right) as whole) ->
    if x = y then (
      whole (* do nothing *)
    )
    else if x < y then (
      Br(y, add left x, right)
    )
    else (
      Br(y, left, add right x)
    );;

add (add Lf 1) 2;;

(*********************************************************)
(* 
 * [プログラム]
 * 以下の2つのプログラムにより、1,2,3,4からなる二分探索木の列挙をおこなった
 * - gen_permitaiton_list: 1,2,...,nからなる順列を列挙する
 * - gen_all_binary_tree: リストアップされた順列に対して
 *)

(*
 * 参考:
 * http://www.geocities.jp/m_hiroi/func/ocaml05.html#chap02
 *)
let gen_permitation_list n =
  let rec gen_descending_sequence n =
    if n = 0 then [] else n :: gen_descending_sequence (n-1)
  in
  (* n ===> [n;n-1; ... ;1] *)

  let list_remove y xs = List.filter (fun x -> x <> y) xs in
  (* list_remove 1 [2;1;4;5;1] ===> [2;4;5] *)

  let rec perm xs p perm_list =
    match xs with
    | [] -> p::perm_list (* 完成した順列をperm_listに追加 *)
    | _ -> 
      List.fold_right
	(fun x p_list ->
	  perm
	    (list_remove x xs) (* removeは呼び出し元に影響しない。fold_rightでリストを走査している間xsは固定 *)
	    (x::p) (* pに蓄積。順列の要素を増やす。順列の要素はリストの後ろから増えていく *)
	    p_list (* 再帰呼び出しされる場合も蓄積中のperm_listは維持される *)
	) 
	xs
	perm_list
  in
  perm (gen_descending_sequence n) [] [];;
gen_permitation_list 3;;
(* 
[[1; 2; 3]; [2; 1; 3]; [1; 3; 2]; [3; 1; 2]; [2; 3; 1]; [3; 2; 1]]
*)

let gen_all_binary_tree perm_list = 
  let make_binary_tree xs =
    List.fold_right (fun x y -> add y x) (List.rev xs) Lf
  in
  (* リスト ===> 順にaddした二分木 *)

  List.fold_right
    (fun x (recipe_list, btree_list) ->
      let new_btree = make_binary_tree x in
      if List.mem new_btree btree_list 
      then (perm_list, btree_list) (* 生成した二分木が重複していた場合は追加しない *)
      else (x :: recipe_list, new_btree :: btree_list)
    )
    perm_list
    ([], []) (* (recipe_list, btree_list) *);;

(*********************************************************)
(* [解答] *)
snd (gen_all_binary_tree (gen_permitation_list 4));;
(* すべての二分木

- : int tree list =
[Br (4, Br (3, Br (2, Br (1, Lf, Lf), Lf), Lf), Lf);
 Br (4, Br (3, Br (1, Lf, Br (2, Lf, Lf)), Lf), Lf);
 Br (4, Br (2, Br (1, Lf, Lf), Br (3, Lf, Lf)), Lf);
 Br (4, Br (1, Lf, Br (3, Br (2, Lf, Lf), Lf)), Lf);
 Br (4, Br (1, Lf, Br (2, Lf, Br (3, Lf, Lf))), Lf);
 Br (3, Br (2, Br (1, Lf, Lf), Lf), Br (4, Lf, Lf));
 Br (3, Br (1, Lf, Br (2, Lf, Lf)), Br (4, Lf, Lf));
 Br (2, Br (1, Lf, Lf), Br (4, Br (3, Lf, Lf), Lf));
 Br (2, Br (1, Lf, Lf), Br (3, Lf, Br (4, Lf, Lf)));
 Br (1, Lf, Br (4, Br (3, Br (2, Lf, Lf), Lf), Lf));
 Br (1, Lf, Br (4, Br (2, Lf, Br (3, Lf, Lf)), Lf));
 Br (1, Lf, Br (3, Br (2, Lf, Lf), Br (4, Lf, Lf)));
 Br (1, Lf, Br (2, Lf, Br (4, Br (3, Lf, Lf), Lf)));
 Br (1, Lf, Br (2, Lf, Br (3, Lf, Br (4, Lf, Lf))))]
*)

fst (gen_all_binary_tree (gen_permitation_list 4));;
(* その作成方法 (listの順にaddしていく)

[[1; 2; 3; 4]; [2; 1; 3; 4]; [1; 2; 3; 4]; [2; 1; 3; 4]; [1; 3; 2; 4];
 [3; 1; 2; 4]; [2; 3; 1; 4]; [3; 2; 1; 4]; [1; 2; 4; 3]; [2; 1; 4; 3];
 [1; 4; 2; 3]; [4; 1; 2; 3]; [2; 4; 1; 3]; [4; 2; 1; 3]; [1; 3; 4; 2];
 [3; 1; 4; 2]; [1; 4; 3; 2]; [4; 1; 3; 2]; [3; 4; 1; 2]; [4; 3; 1; 2];
 [2; 3; 4; 1]; [3; 2; 4; 1]; [2; 4; 3; 1]; [4; 2; 3; 1]; [3; 4; 2; 1];
 [4; 3; 2; 1]]
*)
