* ref
C++マニアック,C++入門,C++講座,よくわかるC++言語プログラミング講座
http://homepage2.nifty.com/well/Index.html
Programming Place Plus　Ｃ言語編　トップページ
http://www.geocities.jp/ky_webid/ProgrammingPlacePlus/c/index.html
Ｃ言語講座＞講座の出入り口＞総目次
http://www1.cts.ne.jp/~clab/Contents/Contents.html

** 本
C言語を独学で習得するのに適した入門書を探してまとめてみた件について - Sickly Life はてな版
http://d.hatena.ne.jp/itiri/20100930/1285857616#linuxp
Amazon.co.jp： オライリー, C実践プログラミング 第3版: Steve Oualline, 望月 康司 (監訳), 谷口 功: 本
http://www.amazon.co.jp/dp/4900900648

* 開発環境
モダンなC, C++の開発環境の構築方法 - 考える人、コードを書く人
http://bokko.hatenablog.com/entry/20100731/1280561128

* コンパイル
Mac
 -arch i386
でうまくいくことも??

* header部/header file
C言語の正しいヘッダファイルの書き方 - saito’s blog
http://d.hatena.ne.jp/saitodevel01/20110321/1300685958
C++マニアック,ヘッダファイルの作り方,How to make header file,C++入門,C++言語講座
http://homepage2.nifty.com/well/Header.html

** using namespace
#+BEGIN_SRC c++
using std::vector;
using namespace std;
#+END_SRC

** include
#+BEGIN_SRC c++
#include <stdio.h>
#include "hoge.h"
#include <string> // c++
#+END_SRC

- C++でCのヘッダをインクルードしたい場合は.hを取り去ってcを付けた名前
stdio.h -> cstdio
をインクルードすべき

** define プリプロセッサ, マクロ
#defineの罠
http://www.geocities.co.jp/bleis_tift/cpp/baddefine.html

Ｃ言語講座：マクロ処理
http://www1.cts.ne.jp/~clab/hsample/Flow/Flow09.html

#+BEGIN_SRC c
#define MAX_LINE 256
#+END_SRC

- =も要らないし、;も要らない

- 定数値は define しよう
  - エラー値を数字にする→後からなんらかの事情でその数値を変えたい場合、
    「全部」書き換えるの大変
  - あるいは、急に「ソート範囲を変えたい」
  - すべて、関数の外で#defineしよう

- C++であれば
class HogeClass {
public:
  static const int c = 1;
}
HogeClass::c
な使い方の方が?

** 構造体の宣言

** global variable 
分割の定石
http://homepage3.nifty.com/mmgames/c_guide/20-02.html#S1

*** 定数を複数ファイルで利用したい
hoge.hh
extern const int i;
// extern は宣言のみおこない、定義（領域確保）はしない

hoge.cc
include "hoge.hh"
const int i = 100;

x 
hoge.hh
static const int i = 100;

global variable を static にするとファイルスコープになるので定義的におかしい
& .hhに記載した変数定義は、宣言と定義を兼ねているので、二重にメモリに格納される

*** 変数を複数ファイルで利用したい
hoge.hh
extern int i;

hoge.cc
include "hoge.hh"
int i; // どこかひとつのファイルで実体の作成 headerに対応するファイルが分かりやすい?

moga.cc
include "hoge.hh"

*** さらに...
二重インクルードによる二重externを防ぐためにインクルードガードする

** 関数のプロトタイプ宣言

* ファイルの分割
最小限の分割
http://homepage3.nifty.com/mmgames/c_guide/20-01.html
分割コンパイルのためのソースファイル分割
http://ysserve.wakasato.jp/sugsi/Lecture/c2/e_12-01-02.html
Programming Place Plus　Ｃ言語編　第２３章　複数ファイルによるプログラム
http://www.geocities.jp/ky_webid/ProgrammingPlacePlus/c/023.html#static_global

* header files
gconio.h (OS Xデフォルトのgccに入っていない模様)
  http://www.wence.vandermeersch.org/gconio/
  http://oshiete.goo.ne.jp/qa/2313653.html

ctype.h
  文字を扱うためのヘッダファイル
  isuppterとか

limits.h
  C言語講座：色々なデータ型の最大値、最小値
  http://www1.cts.ne.jp/~clab/hsample/IO/IO19.html

* 数
| 指数表現 | 1.0e-8 | 

| 絶対値(int)    | abs  | stdlib.h |
| 絶対値(double) | fabs | stdlib.h |
 
* 論理演算子
||
  前者が成り立っていたら後者は調べず真
&&
  前者が成り立っていなかったら後者は調べず偽

* 制御構造
** if
if () {
}
else if () {
}
else {
}

** for, continue, break
for (初期設定; 条件[1 事前チェック]; 次の一歩[3 事後]) {
  文[2];
}

- i=0;i<n;i++ なら、n回繰り返される
- continueで次のループの開始地点へ
- breakで抜ける

** while, continue, break
while (条件[事前チェック]) {
}
・continueで次のループの開始地点へ
・breakで抜ける

** do while (1回以上繰り返すwhile文)
do {
} while (条件);
** switch
switch(値) { # ここには「式」を書く
  case 定数1: { # ここには「定数式」を書く
    文;
    文;
    break;
  }
  case 2:
  case 3: # こんな風に書いておくと、2の場合と3の場合をまとめて記述できる
  case ...
  default:
    
    break;
}

- ひとつの _変数_ を _int型またはchar型の定数_ と比較する
- case 文の中括弧は無くてもOK
  - ただし、case 内にローカル変数を定義する場合は中括弧が必要
- breakも都度無くても良いし、caseの中身が空文でも構わない(複数ケースをまとめて処理できる)
- 同じcaseは二度書けない
- ネストされていれば switch(a) switch(b)など もちろんOK

* io
** ファイルに与える標準入出力の変更(シェルから制御)
<
>

** コマンドライン引数
Head First p.141
結城 p.141

argv[0] ... 実行するプログラム名
argv[1] ... 引数その1

argc ... argvの要素数 引数無ければ1

** 入出力関数群
- ___f ... 書式指定 e.g. fprintf
- f___ ... file pointer 指定

*** input
===> FILE *fp
char* fgets(char* row, int len, FILE *fp);
  改行文字'\n'またはlen-1文字読み込むまで読む
  改行文字は格納される
  最後に'\0'が付与される

- read → null文字入らない??? 返り値のintでsizeを見ないといけないのか

- scanf → 使ってはいけない
- fscanf → 使ってはいけない
- sscanf → OK

**** usage
同じ形が並ぶケース

while(scanf("%d %d %d",&x1,&x2,&y)!=EOF) {
  num++;
}

*** output
===> FILE *fp
- fputs(char* string, FILE *fp); // puts と違い、改行文字は自動では付かない
    fputs("hoge\n", fp)
- fprintf(FILE *fp, "%d\n", n); // file print formatted

===> stdout
- putc('a', fp);
- puts("hoge"); // 改行文字自動付与
- printf(FILE *fp, "%d\n", n);

===> int fd
- write(int fd, buf, read_size);

===> char* string
- strcpy(buf, "hogehoge");
- sprintf(char* string, "%s\n", str);
- 「=」が使える条件?

*** システムコール(read/write)
http://x68000.q-e-d.net/~68user/net/c-open.html
- open や socket で得られた(ファイル|ソケット)ディスクリプタという整数値をそのまま利用する
- cf. printf や fgets の入出力の際は、 FILE 構造体が必要

C 言語で HTTP クライアントを作ってみよう (2)
http://x68000.q-e-d.net/~68user/net/c-http-2.html
ファイル入出力
http://www9.plala.or.jp/sgwr-t/c/sec17.html
Ｃ言語講座：ファイル操作の基本
http://www1.cts.ne.jp/~clab/hsample/File/File01/File01.html
Ｃ言語入門 第１５章　ファイル操作
http://rina.jpn.ph/~rance/c_language/p15.html

** バッファリング
バッファリング方法を設定する | C言語入門講座
http://www.c-lang.net/general55

Programming Place Plus　Ｃ言語編　第４３章　バッファリング
http://www.geocities.jp/ky_webid/ProgrammingPlacePlus/c/043.html

** 書式/format
- http://www1.cts.ne.jp/~clab/hsample/IO/IO18.html

- K&R p.307
- http://itee.uq.edu.au/~comp2303/Leslie_C_ref/C/FUNCTIONS/format.html

- http://www.k-cube.co.jp/wakaba/server/func/fprintf.html
- http://d.hatena.ne.jp/shu223/20110311/1300983799

%[Flags][Minimum field width][Period][Precision][長さ修飾子]ArgumentType

**** Flags (optional)
順序任意

| -     | Left justify.                                 |
| 0     | _Field_ is padded with 0's instead of blanks. |
| +     | Sign of number always O/P.                    |
| blank | Positive values begin with a blank.           |
| #     | Various uses:                                 |

"#"
| %#o (Octal) | 0 prefix inserted.                                        |
| %#x (Hex)   | 0x prefix added to non-zero values.                       |
| %#X (Hex)   | 0X prefix added to non-zero values.                       |
| %#e         | Always show the decimal point.                            |
| %#E         | Always show the decimal point.                            |
| %#f         | Always show the decimal point.                            |
| %#g         | Always show the decimal point trailing zeros not removed. |
| %#G         | Always show the decimal point trailing zeros not removed. |

**** Minimum field width (optional)
- 最小フィールド幅を指定
- 印字すべき文字数の方が少なかった場合

詰める方向
| default | 右詰め |
| Flags:- | 左詰め |

埋める文字
| defalut | blank |
| Flags:0 | 0埋め |

**** Period (optional)
- Minimum field width と Precision を分離? (K&R)
- Precision の前に必須? http://itee.uq.edu.au/~comp2303/Leslie_C_ref/C/FUNCTIONS/format.html

**** Precision, Maximus field width (optional)
| e, E, f | 小数点の後に印字すべき桁数             |
| g, G    | 有効数字の桁数                         |
| 整数    | 印字すべき最小(最大?)桁数 (不足があれば0埋め) |

**** 長さ修飾子 (optional)
| h | 引数が short, unsigned short であることを示す |
| l | 引数が long,  unsigned long  であることを示す |
| L | 引数が long double であることを示す           |

**** Argument type (required)
int
| d, i | int ==> 符号付き10進数                     |
| u    | int ==> 符号なし10進数                     |
|------+--------------------------------------------|
| o    | int ==> 符号なし8進数                      |
| x, X | int ==> 符号なし16進数                     |
|------+--------------------------------------------|
| c    | int ==> unsigned char に変換された後の文字 |

char *
| s |   | 

double
| | |  

%d  int
%8d 最低8文字分のスペースを使って右詰めで整数を表示
%ld 長整数
%02x 16進小文字?
%02X 16進?

%f  float 12.340000
%lf double
%6f 少なくとも6桁(小数点以下を入れる) 12.340000
%6.0f 少なくとも6桁＆小数点以下表示せず  ____12
%6.1f 少なくとも6桁&小数第1位まで ___12.3
%0.1f 桁気にしない&小数点以下1位まで 12.3

| char                         | %c                         |
| char *                       | %s                         |
|------------------------------+----------------------------|
| int, short                   | *%d*,  (8進)%o,  (16進)%x  |
| unsigned int, unsigned short | *%u*,  (8進)%o,  (16進)%x  |
| long                         | *%ld*, (8進)%lo, (16進)%lx |
| unsigned long                | *%lu*, (8進)%lo, (16進)%lx |
|------------------------------+----------------------------|
| float                        | %f                         |
| double                       | %lf                        |


| %c | 文字   | 'a'                   |
| %s | 文字列 | "hoge", char buf[256] |

%p  ポインタの値

* ファイル操作
Robotics/file_io - NAIST::OnlineText
http://robotics.naist.jp/edu/text/?Robotics%2Ffile_io#r531eaa8

** ファイルポインタ(FILE *fp)、ファイルディスクリプタ(int fd)
*** fdopen (fd ===> fp)
http://www5c.biglobe.ne.jp/~ecb/c/13_09.html
ディスクリプタ -> FILE 構造体
FILE *fp;
fp = fdopen(fd, "r");

*** ファイルディスクリプタの種類(int fd)
| stdin  | 0 |
| stdout | 1 |
| stderr | 2 |

*** ファイルポインタの生成(fopen)
FILE *fp;
if((fp = fopen(file_name, "r")) == NULL) {
  fprintf(stderr, "error: failed to open file(%s)", file_name);
  exit(1);
}

// exitはstdlib.h要

* pointer
** 関数ポインタ
double Add(double a, double b){ return a + b; }
double Sub(double a, double b){ return a - b; }
double Mul(double a, double b){ return a * b; }
double Div(double a, double b){ return a / b; }

double (* const afpOps[])(double, double) = {
    Add, Sub, Mul, Div,
};

afpOps[0](1,2);
* 文字列
** 初期化
char buf[100] = "";

** コピー
strcpy, strncpy, sprintf, snprintf の違い
http://mura.stoic.jp/2005/11/sprintf_1/

*** strcpy
strcpy(char* p1, char* p2);
- strlen(p1) < strlen(p2) だと、メモリ割当されていない場所にまで書き込もうとしてバッファオーバーフロー
- bufにメモリ領域が割り当てられているものとして、1文字毎に(配列の1要素毎に)代入
- ANSI 非標準?
  http://www.jpcert.or.jp/sc-rules/c-msc34-c.html
- strcpy(ptr2, ptr1) is equivalent to while(*ptr2++ = *ptr1++)
  http://stackoverflow.com/questions/14020380/strcpy-vs-strdup

*** strncpy
文字列長指定

*** sprintf
sprintf(buf, "hoge %d", i);

*** snprintf

*** strdup
- ANSI 非標準?
  http://www.jpcert.or.jp/sc-rules/c-msc34-c.html
- strdup(ptr1, ptr2) is equivalent to
  ptr2 = malloc(strlen(ptr1)+1);
  strcpy(ptr2,ptr1);
  http://stackoverflow.com/questions/14020380/strcpy-vs-strdup
- free要?

*** strndup
自作
http://blog.sarabande.jp/post/59480229716
char* duplicate(char *str, size_t len) {
    char *buffer = malloc(len + 1);
    memcpy(buffer, str, len);
    buffer[len] = '\0';

    return buffer;
}

** 分割
**** strtok
- fgetsやreadなどで'\n'を含む文字列を入力している可能性がある場合、
  \nをtokenに入れる
- tpをchar*型の変数に=で突っ込めば文字列として使えるようになる
  - なぜ??

http://www9.plala.or.jp/sgwr-t/lib/strtok.html
http://www.c-tipsref.com/tips/string/strtok.html
http://www.k-cube.co.jp/wakaba/server/func/strtok.html

char *tp;
tp = strtok(buf, " :\n");
while(tp != NULL) {
  puts(tp);
  tp = strtok(NULL, " :\n");
}

** 比較 strcmp (ストルコンプ) <string.h>
文字列比較
一致すれば0を返す
http://www9.plala.or.jp/sgwr-t/lib/strcmp.html

** 部分文字列 sbstr <string>
#+BEGIN_SRC c++
#include <string>
using namespace std;

string str("abcdefg");
str.substr(5); // 5文字目以後 (0文字目はじまり)
str.substr(5,3); // 5文字目から3文字
#+END_SRC

** reverse <string>
string s = "hello";
reverse(s.begin(), s.end());
cout << s << endl;

** 長さ strlen(char*), string.size
* 構造体(structure)
#+BEGIN_SRC c
typedef struct h {
} *hoge;

typedef union nd { /* tree */
    struct {
	int op;
    } n;
    struct tp tp;
    struct tk tk;
    struct c c;
} *tree;
tree t = (union nd *)malloc(sizeof(union nd));
#+END_SRC

構造体のメンバ
s.hoge
構造体へのポインタからメンバを指す
p->hoge
  
typedef
  http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1254746057
  使うときに struct h でなくて、 hoge で済むようになる

*
  〜を指すポインタ型の変数を定義
  http://www.ced.is.utsunomiya-u.ac.jp/lecture/2011/prog/p2/kadai2/typedef.php

** 宣言
struct 構造体タグ {
  int id;
  char name[20];
  ...
}; // セミコロン付ける

・構造体タグは変数名ではない
・メンバ：id,nameなど
・idという変数が定義されているわけではない
    × int id = 10;

** 定義
struct student taro;
型名：「struct student」

** -- 定義+初期化
struct student taro = {10, "Yamada", …};
構造体の配列の初期化
struct student data[3] = {
  {20, "Suzuki", …},
  {11, …},
  … ★最後まで「,」打ってOK!!なんと。ref.結城本
}

** 代入
taro.id = 2; // ポインタでない変数の場合
tarop->id = 2; // ポインタ変数の場合

jiro = taro;
同じ型であれば、まるまるコピーできる

** 参照
taro.id
* 列挙型(enum)
C++マニアック,enum の使い方,列挙型の使い方,how to use enum,C++言語講座
http://homepage2.nifty.com/well/enum.html

enum hoge {FOO, BAA, BAZ};

* メモリ割り付け malloc, free
http://www1.cts.ne.jp/~clab/hsample/Mem/Mem1.html
* 型変換
| string | char*  | str.c_str()            |                                         |
| char*  | string | string s = string(str) |                                         |
| char*  | int    | atoi(str)              | stdlib.h                                |
| string | int    | std::stoi(s)           |                                         |
| bool   | int    | (int)b                 | そのまま b でも良かった sstreamに流す際 |
| char   | int    | (int)(c - '0')         |                                         |

** int -> char*, str
1. sprintf
sprintf(s, "%d", i);

2. stringstreamに任せる
#+BEGIN_SRC c++
#include <sstream>
stringstream ss;
ss << 1;
ss << "hoge";
ss.str().c_str();
#+END_SRC

** 数値 → 文字列
#+BEGIN_SRC c
sprintf(s, "%d", 123)
string printf
#+END_SRC

進数変換もできる
%o 10進数→8進数
%x 10進数→16進数

* ビット演算
Programming Place Plus　Ｃ言語編　第４９章　ビット演算
http://www.geocities.jp/ky_webid/ProgrammingPlacePlus/c/049.html

C++14からは二進数リテラル(int x = 0b1011;)が追加される
http://faithandbrave.hateblo.jp/entry/20130502/1367481106
