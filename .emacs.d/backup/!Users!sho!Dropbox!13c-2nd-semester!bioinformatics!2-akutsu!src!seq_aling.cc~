int similarity_with_glob_align(string &a, string &b) {
  string dummy_str1, dummy_str2;
  return glob_align(a, b, dummy_str1, dummy_str2, DONT_NEED_TRACEBACK);
}
int glob_align(string &a_in, string &b_in, string &a_out, string &b_out,
			   enum need_traceback nb) {
  int D[SEQ_MAX_LEN + 1][SEQ_MAX_LEN + 1];
  int i_max = a_in.size();
  int j_max = b_in.size();

  for (int i=0; i<=i_max; i++)
	D[i][0] = i * Score::gap_cost;
  
  for (int j=1; j<=j_max; j++)
	D[0][j] = j * Score::gap_cost;
  
  for (int i=1; i<=i_max; i++) {
	for (int j=1; j<=j_max; j++) {
	  D[i][j] =  max(max(D[i-1][j] + Score::gap_cost,
						 D[i][j-1] + Score::gap_cost),
					 D[i-1][j-1] + (a_in[i-1] == b_in[j-1] ? Score::same : Score::diff));
	}
  }

  if (nb == NEED_TRACEBACK)
	traceback(D, a_in, b_in, i_max, j_max, a_out, b_out);
  
  return D[i_max][j_max];
}

void traceback(int (&D)[SEQ_MAX_LEN+1][SEQ_MAX_LEN+1], string &a_in, string &b_in,
			   int i, int j, string &a, string &b) {
  
  if (i == 0 && j == 0) {
	reverse(a.begin(), a.end());
	reverse(b.begin(), b.end());
	return;
  }
  else if (j == 0) { // →
	a += a_in[i-1];
	b += '-';
	traceback(D, a_in, b_in, i-1, j, a, b);
  }
  else if (i == 0) { // ↓
	a += '-';
	b += b_in[j-1];
	traceback(D, a_in, b_in, i, j-1, a, b);
  }
  else {
	if (D[i][j] == D[i-1][j] + Score::gap_cost) { // →
	  a += a_in[i-1];
	  b += '-';
	  traceback(D, a_in, b_in, i-1, j, a, b);
	}
	else if (D[i][j] == D[i][j-1] + Score::gap_cost) { // ↓
	  a += '-';
	  b += b_in[j-1];
	  traceback(D, a_in, b_in, i, j-1, a, b);
	}
	else { // D[i-1][j-1] + (a_in[i-1] == b_in[j-1] ? Score::same : Score::diff)
	  a += a_in[i-1];
	  b += b_in[j-1];
	  traceback(D, a_in, b_in, i-1, j-1, a, b);
	}
  }
}
