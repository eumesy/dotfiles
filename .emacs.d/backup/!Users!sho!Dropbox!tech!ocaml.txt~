★OCaml 開発環境について ~ コンパイラに付属しない非公式ツールたち - Oh, you `re no (fun _ → more)
http://d.hatena.ne.jp/camlspotter/20121215/1355577547

■言語仕様
Objective Caml 入門 (HTML版)
http://www.fos.kuis.kyoto-u.ac.jp/~t-sekiym/classes/isle4/mltext/ocaml.html

The OCaml system, release 4.01
http://caml.inria.fr/pub/docs/manual-ocaml/index.html

Module
http://caml.inria.fr/pub/docs/manual-ocaml/libref/index.html
e.g. String.length "hoge"

和訳
The Objective Caml system release 3.11
http://ocaml.jp/archive/ocaml-manual-3.11-ja/

OCaml 基礎最速マスター — MAYAH.JP
http://mayah.jp/scratchleaf/2010/ocaml-%E5%9F%BA%E7%A4%8E%E6%96%87%E6%B3%95%E6%9C%80%E9%80%9F%E3%83%9E%E3%82%B9%E3%82%BF%E3%83%BC


■実行環境
・ocaml // 使いづらいらしい
・tuareg mode // おすすめしているサイトが多い

■Tuareg mode
□インストール
  http://tuareg.forge.ocamlcore.org/
  -> released files

  旧
  https://who.rocq.inria.fr/Albert.Cohen/tuareg/mode/
  
□インタプリタ
M-RET
  ;; して評価
M-p M-n
  履歴移動

□エディタ
C-x C-e
  カーソルがある行の式を評価

■課題
□コンパイル
C-c C-c make -k

□実行
rlwrap ./miniml


■教科書
Object Caml入門の手習い
http://ymotongpoo.hatenablog.com/search?q=Objective+Caml+%E5%85%A5%E9%96%80


■資料
関数プログラミング 筑波大学 情報科学類 3年次実験（ソフトウェアサイエンス実験）
http://logic.cs.tsukuba.ac.jp/~kam/jikken/index.html

■開発環境
開発環境 - OCaml.jp
http://ocaml.jp/%E9%96%8B%E7%99%BA%E7%92%B0%E5%A2%83



■文法

□文ブロック
begin
;
;
;
end

(
;
;
;
) (* begin/endのsyntax sugar *)

---

変数宣言
  let v = value
局所変数「式」
  let x = e1 in e2

□関数
関数宣言
  let func_name(arg [: 型]) [: 型] = 式;;
再帰の場合
  let rec ...

OCamlの関数はすべて1引数

無名関数
  (fun x -> x + 1)
  
  function <パターン> -> <式1> | ... <パターンn> -> <式n>
  = fun x -> match x with <パターン> -> <式1> | ... <パターンn> -> <式n>

パターン
  (パターン) as 変数
  パターンにマッチした値全体を変数で参照できるようになる

■真理値
&&
||

■データ型
□組型
  (,,)
  // _（を含めた変数の組） でパターンマッチして代入できる

  fst
  snd

□リスト
http://caml.inria.fr/pub/docs/manual-ocaml-4.01/libref/List.html

生成
  []      nil
  e :: l  cons
  [e1; e2; ... en]  e1 :: e2 :: ... :: en

パターンマッチ
  List.hd car
  List.tl cdr

  [e1; e2; ... en] 要素数nのリスト
  [x] 要素数1のリスト
  x :: rest
  e1 :: e2 :: rest
  
  matchで再帰 (p.53)
- 各要素は同じ型(e.g. int -> int, int list)である事が求められる

チェック
  null   p.54

□レコード型
・構造体的なもの

・宣言
  type student = {name : string; id : int};;
  
  type teacher = {name : string; mutable office string};;
  更新可能レコード

  ・更新可能レコードの更新
    t.office <- "142";

・構成
  let st1 = {name = "Taro Yamada"; id = 123456};;
・一部を変更したレコードの構成
  let sty = {sty with id = 123457};;
  
・get
  st1.name

・パターン
  {name = n; id = i}

・フィールド名はユニークに取る
  ・別モジュールにすればOK
  ・変数名、フィールド名、型名は、はじめから別のname space に属する

□ヴァリアント型
  共用体みたいなもの
  type Hoge | Moga x

  orパターン（p.66）

  関数
    let f = function C1 -> hoge | C2 -> ...
  
  コンストラクタは大文字ではじめる


□
型キャスト
  float_of_int // int -> float

□制御
if . then . else .

逐次実行
  e1; e2; e3;

matchのネスト
begin   // (
end     // )
if then else のネストと同じ問題が起き得る

■参照
t型への参照値＝t ref型
ポインタのようなもの

構成
  let p = ref 5;; // メモリ空間に5を格納してそのアドレスがpに束縛される

get
  !p // 参照pに格納されえちる値を取り出す

破壊的代入
  p := !p + !q;; // 破壊的代入

■例外
新しい例外の宣言
  exception Foo;; // 任意の型
  // 例外名は必ず英大文字ではじめる

  exception Bar of int;; // t型を伴う（＝引数に取る？）例外

例外の発生
  raise Foo;;
  
型を伴う例外の宣言
  exception Bar of int;;
型を伴う例外の発生
  raise (Bar 2);; // 例外「Bar 2」が発生

例外の検知
  try <式> with
      <パターン1> -> <式1>
    | ...

