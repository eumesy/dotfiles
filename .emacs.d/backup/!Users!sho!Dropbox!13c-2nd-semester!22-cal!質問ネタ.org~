

■131022 1 Basics 前半 <コメント欄>
[質問]
Fixpoint で再帰的関数を定義する際、(decreasing in nth argument) とメッセージが出ます。
これについて、講義中「第n引数がどんどん"減って"」いると説明がありましたが、これは、
「コンストラクタが外れていく」という意味で合っていますか？
＝型定義において、コンストラクタは常に付与する（増やす）もの、という認識で良いでしょうか？
[感想]
翌週のレジュメを配布して頂くのは、予習に取り組みやすく、ありがたいです。

■131022 2 Basics 後半、Induction <質問票>

■131029 2 Basics 後半、Induction <コメント欄>
evenb （Oに向けて再帰していく事で偶数判定） は、計算量的に、とても「使える」ものに見えません。
再帰の練習として用いているだけなのでしょうか。
それとも、プログラムの「証明可能性」と「高速性」は、ある意味でトレードオフなのでしょうか。
  
■質問
□1 Basics 前半
・簡約で証明 簡約は一意？
・Eval simpl in (next_weekday (next_weekday saturday)). (* 関数評価も関数そのものも記法同じ? *)
(*引数を書いたら関数適用? *)
・simpl compute違い気になる
・nat、元々あるものを更に上書きしている？
・evenb （レジュメ p.57）とても「使える」ものには見えない
  練習として使っているだけ？
  それとも、プログラミング言語の「証明可能」と「高速」はトレードオフ？
・Notationのnat_scopeなに？

□2 Basics 後半
intros は、**定理のこと？
・Case "n = 0"より =O の方が良い気が
・plus_O、plus_0 気持ち悪い…

intros n. 型だけ仮定した変数を仮定におく？

-> を使う対象は決められないの?

□Induction
これは背理法??
  false = true, b = false -> b = true

・〜定理？

・過去二つとか、過去全部を引き継ぐ帰納法は無い??

□Lists
いきなり
natprod is defined
natprod_rect is defined
natprod_ind is defined
natprod_rec is defined
て何?
1疋数の場合も出てるな… natもたぶん出る

hd_opt
  Nilを後から出さないとredunduntになるのは何事…

帰納法＝好きにコンストラクタを付けてよい の証明 (in Coq) ということ？

nonzeros_app、0だからnで場合分けできたけれど、そうでない場合分けは？
いちいち新しい型を用意しないといけない？


■todo
・大谷氏解答と見合わせたい

■感想など
□1
・講義の裏テーマ 証明＝プログラム 触れて欲しい
