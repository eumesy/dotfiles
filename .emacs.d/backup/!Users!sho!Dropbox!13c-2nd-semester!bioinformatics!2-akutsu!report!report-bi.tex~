\documentclass[]{jsarticle}

%% font
\usepackage[T1]{fontenc} % 8ビットエンコーディング <,|,> の直書き
\usepackage{textcomp} % 文字種追加
\usepackage[deluxe]{otf} % 文字種追加. deluxe:日本語フォントが5書体(太細×明ゴ＋丸ゴ)使えるようになる

%% math
\usepackage{amsmath,amssymb} % 数学記号の追加
\usepackage{bm} % 数式の太字 \bm{}
\usepackage{cancel} % 数式に打ち消し合いを示すための斜め線

%% table
\usepackage{array} % tabular拡張
\usepackage{multirow}

%% figure
\usepackage[dvipdfmx]{graphicx}

%% arrange tables or figures
\usepackage{float}

\usepackage{listings}
\lstset{
 language=C++,
 basicstyle=\ttfamily\footnotesize,
%  frame=tbrl, %枠を上下左右に表示
 breaklines=true, % 行が長くなった場合に改行
 numbers=left,
 xleftmargin=4zw
}
\usepackage{url}

\catcode`@=\active
\def@#1@{\texttt{#1}}

%% レイアウト
% title補正
\addtolength{\textheight}{\topskip}
\setlength{\voffset}{0pt}
\setlength{\topmargin}{0pt}
\setlength{\headheight}{0pt}
\setlength{\headsep}{0pt}
% \pagestyle{empty} % ページ番号非表示

\title{生命情報学\\
阿久津 達也 先生分レポート課題\\
マルチプル・アラインメントの実装}
\author{横井 祥（よこい しょう）\\
学籍番号：1029-23-2177\\
工学部 情報学科 計算機科学コース 3回生}
%% \title{English IIA E2T01; Professor Hayashi, Brian\\Homework \#1}
%% \author{Yokoi, Sho; 1029-23-2177} % ほか
\date{\today}\西暦
\begin{document}
\maketitle

\tableofcontents % 目次の表示
%% \newpage

\section{概要}
プログレッシブ・アラインメントによるマルチプル・アラインメントを実装した。

\bigskip
作成した実行ファイルは、与えた配列の集合に対して次の処理をおこなう。
\begin{enumerate}
\item ペアワイズ・アラインメントにより各配列間の類似度を計算
\item 類似度を距離に変換
\item 近隣結合法により案内木を作成
\item 案内木に従って順にアラインメントを実行
\end{enumerate}

以下、詳細を述べる。

\section{実装}
実装はC++による。
%% モジュール毎に実装の方針を述べる。

\subsection{ペアワイズ・アラインメント}
\begin{itemize}
\item 各配列間の類似度の計算\\
関数:
\begin{lstlisting}[numbers=none]
int similarity_with_glob_align(std::string &a, std::string &b);
\end{lstlisting}
\item 案内木に従ったアラインメント
\begin{itemize}
\item 配列—配列
\item 配列—プロファイル
\item プロファイル—プロファイル
\end{itemize}
関数:
\begin{lstlisting}[numbers=none]
std::vector<std::string> global_alignment(std::vector<std::string> &a, std::vector<std::string> &b);
\end{lstlisting}
\end{itemize}
は、動的計画法による大域アラインメントによっておこなった。

ここで、各関数には配列・プロファイルのいずれも与えられるようにした。
引数は文字列を複数格納するベクトル型 \verb|vector<string>|とし、対象が配列だった場合は要素数1のベクトル、対象がプロファイルだった場合は要素数が2以上のベクトルとなる。

\bigskip
類似度スコアは以下を設定した。
\begin{itemize}
\item 同じ文字 ... $+1$
\item 違う文字 ... $-1$
\item ギャップ ... $-1$
\item ギャップとギャップ ... $0$ (※)
\end{itemize}
なお、「ギャップとギャップ」のスコアは、配列—プロファイルアラインメント、プロファイル—プロファイルアラインメントで利用した。

\subsubsection{ソースコード}
ソースコードは本レポート末尾に添付。
\begin{itemize}
\item \verb|pair_align.hh|
\item \verb|pair_align.cc|
\end{itemize}

\subsection{類似度→距離の変換}
大域アラインメントで得られるスコアは類似度（「近い」ほど「大きい」）だが、近隣結合法により案内木を作成する際には（加法性を満たす）距離（「近い」ほど「小さい」）が必要である。

ここでは、
\begin{itemize}
\item 実際に計算した配列間類似度が最小値$\mapsto$ 距離1
\item 最長配列を同一配列同士でアラインメントした場合に得られるスコア$\mapsto$ 距離0
\end{itemize}
となるように正規化をおこなった。

\subsubsection{ソースコード}
類似度（\verb|similarity[i][j]|）を距離（\verb|distance[i][j]|）に変換する部分のソースコードは以下の通り。

\verb|multi_align.cc|
\begin{lstlisting}
  const int similarity_max_theorical = Score::same * seq_len_max;
  int similarity_range;
  similarity_range = similarity_max_theorical - similarity_min;
  vector<vector<double> > distance(num_of_seq, vector<double>(num_of_seq));
  for (int i=0; i<num_of_seq; i++) {
	for (int j=0; j<num_of_seq; j++) {
	  if (j == i)
		continue;
	  else if (j > i) // 正規化
		distance[i][j] = 1.0 - ((similarity[i][j] - similarity_min) / (double)similarity_range);
	  else // j < i
		distance[i][j] = distance[j][i];
	}
  }
\end{lstlisting}


\subsection{近隣結合法による案内木の作成}
計算した配列間距離に基づき、近隣結合法により案内木を作成する。

\bigskip
案内木の葉（処理対象の配列ひとつひとつ）および中間ノード根ノード（これらにはプロファイルが格納される）のデータ構造を次のように定義した。
\begin{lstlisting}[numbers=none]
struct tree_node {
  int node_index; // ノード番号
  int fst_child_index; // 子(ひとつめ)のノード番号
  int snd_child_index; // 子(ふたつめ)のノード番号
  std::vector<std::string> profile; // プロファイル(葉の場合は配列)
};
\end{lstlisting}

葉は、子を持たないので  \verb|fst_child_index, snd_child_index|を持たず、 \verb|profile|には配列そのものが格納される。

中間ノード・根ノードは子（\verb|fst_child_index, snd_child_index|）を持ち、 \verb|profile|には子を大域アラインメントした結果のプロファイルが格納される。

\bigskip
案内木\verb|guide_tree| は \verb|vector<struct tree_node>|にて実装した。
近隣結合法において新たに中間ノード（または根ノード）が生成される度に、その新しい中間ノード（または根ノード）が案内木 \verb|vector<tree_node> guide_tree|にpushされる。

したがって、この後マルチプルアラインメントを実行する際には、\verb|guide_tree|の葉以外のノードについて、\verb|guide_tree|に格納されている順に \textbf{一方の子のプロファイルともう一方の子のプロファイルを大域アラインメントした結果を自身のプロファイルとする} 処理をおこなえば良い。

\subsubsection{ソースコード}
ソースコードは本レポート末尾に添付。
\begin{itemize}
\item \verb|phylogenetic_tree.hh|
\item \verb|phylogenetic_tree.cc|
\end{itemize}

%% \subsection{全体像}

\section{実行結果}
講義資料『生命情報学(2) 配列解析基礎』内「プログレッシブ・アラインメント」に示されている4つの配列 \verb|ACCGA, ACGAT, CCAGAT, CGAAT|を与えた結果は以下の通り。
\lstinputlisting[numbers=none]{../src/result}
講義資料と同様のマルチプル・アラインメントが実現できたことが分かる。

\section{考察・課題}
%% \subsection{類似度スコアから距離スコアへの変換}
%% 類似度スコアを距離スコアに変換する際、\cite{Mount} では、「同一配列同士のアラインメントで得られるスコア（最高スコア）」と「両配列を何度もシャッフルした結果得られるスコアの平均（背景平均スコア）」に基づき正規化する例（Feng, Doolittle; 1996）が紹介されている。

%% 類似度スコアから距離スコアの変換では、
%% \begin{itemize}
%% \item 類似度:大$\leftrightarrow$距離:小 の関係性
%% \item 距離の非負性
%% \end{itemize}
%% は保たれるが、果たして計算した距離スコアがどの程度類似度スコアの情報を反映したものになっているかが

%% \subsection{逐次改善法}
今回作成した実行ファイルの仕様では、同一の類似度スコアとなる配列の組み合わせが複数あった場合、近隣結合法により最初に取り出される配列のペアが何になるかは配列に付与されるインデックスに依存する。

実際、講義資料にて与えられた文字列の集合を異なる順番で与える（\verb|CCAGAT, ACCGA, ACGAT, CGAAT|）と、マルチプル・アラインメントの結果が変わる。

\lstinputlisting[numbers=none]{../src/result2}

より良いマルチプル・アラインメントを実現するための方法として、以下の方法が考えられる。

\begin{itemize}
\item アフィンギャップコストの導入\\
今回はギャップコストを一律で計算（線形コスト）したが、実際の
\end{itemize}


\subsection{課題}
\begin{itemize}
\item 線形ギャップスコア
\item 類似度→距離の変換 ランダムにしたかったけど…
\item 逐次改善法
\end{itemize}


\section{ソースコード}
\subsection{ペアワイズ・アラインメント}
\verb|pair_align.hh|
\lstinputlisting[]{../src/pair_align.hh}
\verb|pair_align.cc|
\lstinputlisting[]{../src/pair_align.cc}

\subsection{近隣結合法による案内木の作成}
\verb|phylogenetic_tree.hh|
\lstinputlisting[]{../src/phylogenetic_tree.hh}
\verb|phylogenetic_tree.cc|
\lstinputlisting[]{../src/phylogenetic_tree.cc}

\subsection{マルチプル・アラインメント}
\verb|multi_align.cc|
\lstinputlisting[]{../src/multi_align.cc}


\begin{thebibliography}{99}
\bibitem{Akutsu} 阿久津達也. 『バイオインフォマティクスの数理とアルゴリズム』, 共立出版, 2007.
\bibitem{Mount} David W. Mount 著. 岡崎康司, 坊農秀雅 監訳. 『バイオインフォマティクス : ゲノム配列から機能解析へ』, 第2版, メディカル・サイエンス・インターナショナル, 2005.
\end{thebibliography}

\bigskip
\begin{flushright}
以上
\end{flushright}
\end{document}
