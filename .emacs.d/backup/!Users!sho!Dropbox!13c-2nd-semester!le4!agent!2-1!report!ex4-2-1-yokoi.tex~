\documentclass[]{jsarticle}
%% \setlength{\textheight}{37\baselineskip} % 11pt
%% \setlength{\textheight}{35\baselineskip} % 12pt

%% font
\usepackage[T1]{fontenc} % 8ビットエンコーディング <,|,> の直書き
\usepackage{textcomp} % 文字種追加
\usepackage[deluxe]{otf} % 文字種追加 

%% math
\usepackage{amsmath,amssymb} % 数学記号の追加
\usepackage{bm} % 数式の太字 vector等 e.g. \bm{a}
\usepackage{cancel} % 数式に打ち消し合いを示すための斜め線

%% table
\usepackage{array} % tabular拡張
\usepackage{multirow}

%% figure
\usepackage{float}
\usepackage[dvipdfmx]{graphicx}

\usepackage{listings}
\lstset{
 language=C++,
 basicstyle=\ttfamily,
 numbers=none,
 xleftmargin=4zw
}
\usepackage{url}

\catcode`@=\active
\def@#1@{\texttt{#1}}

%% レイアウト

%% title補正
\addtolength{\textheight}{\topskip}
\setlength{\voffset}{0pt}
\setlength{\topmargin}{0pt}
\setlength{\headheight}{0pt}
\setlength{\headsep}{0pt}

% \pagestyle{empty} % ページ番号非表示

\title{計算機科学実験及演習4 - エージェント\\課題1-2 レポート}
\author{工学部 情報学科 計算機科学コース 3回生
\\横井 祥（よこい しょう）
\\学籍番号：1029-23-2177}
%% \title{English IIA E2T01; Professor Hayashi, Brian\\Homework \#1}
%% \author{Yokoi, Sho; 1029-23-2177} % ほか
\date{\today}\西暦
\begin{document}
\maketitle

% \tableofcontents % 目次の表示
% \newpage

\section{プログラム概要}
ネットワークを介してオークションに参加するクライアントを作成した。

次の機能を含む。
\begin{itemize}
\item サーバとの通信機能
\item 入札額決定機能（現在は、常に商品g1にのみ入札をおこなう仕様としてある）
\item サーバから与えられた入札結果の蓄積機能
\item 蓄積された入札結果をSVMへの入力として識別器を作成する機能
\end{itemize}

\section{外部仕様}
%% 生成される実行可能ファイル@svm@は、
%% \begin{itemize}
%% \item 学習データ（標準入力より）
%% \item 交差検定時のデータ分割数 \verb|n|（コマンドライン引数より）
%% \item カーネルの種類とそのパラメータ（コマンドライン引数より）
%% \end{itemize}
%% を受け取り、生成される識別関数の精度を出力する。

%% 以下に詳細を記す。

\subsection{ファイル名}
\begin{itemize}
\item \verb|client.cc| : サーバとの通信、入札結果の蓄積をおこなう
\item \verb|svm.cc, svm.hh| : 蓄積された入札結果を受け取り、線形識別器（$\alpha,\theta$の組）を生成する
\item \verb|QuadProg++.cc, QuadProg++.hh| : 二次計画問題のソルバ
\item @Makefile@
\end{itemize}

\subsection{コンパイル方法}
同梱の \verb|Makefile| に従い\\
\verb|$ make| \\
にてコンパイルをおこなう。

コンパイルが完了すると実行可能ファイル@client@が生成される。

%% \subsection{入力ファイル}
%% 実行可能ファイル@svm@は、学習データを入力ファイルとする。

%% 学習データは、各行にm次元の特徴ベクトルとそのクラス（$1$または$-1$）がスペース区切りで記載されているものとする。

%% 例えば\\
%% @1 2 3 -1@\\
%% は、特徴ベクトル$(1,2,3)^T$でクラス$-1$のデータを表す行である。

%% 実験のウェブページで与えられたファイル@sample\_linear.dat@や@sample\_circle.dat@は適切な入力ファイルとなる。

%% \subsection{出力ファイル}
%% 実行可能ファイル@svm@の出力は、



\subsection{実行方法}
\verb|$ ./client [hostname] [port number] [agent name]|\\
のように、実行可能ファイル \verb|client| のコマンドライン引数として、順に
\begin{enumerate}
\item ホスト名
\item ポート番号
\item 自身を識別する名前
\end{enumerate}
を与えることで実行できる。

\bigskip
例えばサーバが、ホスト名: localhost、ポート番号: 1234で起動していた場合は、\\
\verb|$ ./client localhost 1234 yokoi|\\
のように実行する。

%% \subsubsection{実行例}
%% \begin{itemize}
%% \item \verb|$ /.svm 10 0 < sample_linear.dat| \\
%% 学習データとして \verb|sample_linear.dat| を与え、分割数$10$で交差検定をおこなう。
%% 用いるカーネルは線形カーネル。
%% \item \verb|$ /.svm 10 2 30 < circle_linear.dat| \\
%% 学習データとして \verb|sample_circle.dat| を与え、分割数$10$で交差検定をおこなう。
%% 用いるカーネルはGaussカーネル（$\sigma = 30$）。
%% \end{itemize}

\section{内部仕様}
プログラム \verb|client.cc| の内部仕様は以下の通り。

\subsection{関数}
\begin{itemize}
\item サーバから送られてきたエージェント名のリストを、変数 \verb|vector<char*> agent_names| に格納する関数
\begin{lstlisting}
void save_agent_names(char* buf, int read_size,
     vector<char*>& agent_names);
\end{lstlisting}
\item 入札結果を蓄積するファイル名を、変数 \verb|vector<vector<string> > dat_names|に格納する関数
\begin{lstlisting}
void save_dat_names (vector<char*>& agent_names, 
     int num_of_agents, int num_of_goods, int my_id,
     vector<vector<string> >& dat_names);
\end{lstlisting}

\end{itemize}


\begin{itemize}
\item ベクトルを計算するための関数
\begin{lstlisting}
// 内積
double inner_product_v(vector<double>& v1, vector<double>& v2);
// スカラー倍
vector<double> c_v(double c, vector<double>& v);
// 和
vector<double> plus_v(vector<double>& v1, vector<double>& v2);
// 差
vector<double> minus_v(vector<double>& v1, vector<double>& v2);
// ユークリッドノルムの二乗（＝ベクトルの各要素の平方和）
double norm_square_v(vector<double>& v);
\end{lstlisting}

\item 2つのベクトルに対して、そのカーネルを計算する関数
\begin{lstlisting}
// 線形カーネル
double kernel_0(vector<double>& x1, vector<double>& x2);
// 多項式カーネル
double kernel_1(vector<double>& x1, vector<double>& x2);
// Gauss カーネル
double kernel_2(vector<double>& x1, vector<double>& x2);
// シグモイドカーネル
double kernel_3(vector<double>& x1, vector<double>& x2);
// 以上 4 種の関数を格納する関数（関数ポインタの配列）
double (*kernel_func[4])(vector<double>&, vector<double>&) =
{ kernel_0, kernel_1, kernel_2, kernel_3 };
\end{lstlisting}

\item 学習データを標準入力から読み込み、内部形式に格納する関数
\begin{lstlisting}
void read_data(vector<vector<double> >& x, vector<int>& y);
\end{lstlisting}

\item コマンドライン引数の過不足に際して、エラーメッセージを出力した上でプロセスを終了させる関数
\begin{lstlisting}
void alert_arg();
\end{lstlisting}

\item 二次計画問題を解く関数。求めたLagrange乗数$\alpha_i$は引数 \verb|vector<double> alph|に格納される
\begin{lstlisting}
void solve_quad_problem
  (vector<vector<double> >& x, vector<int>& y,
   double alph[MATRIX_DIM]);
\end{lstlisting}

\item 識別関数の閾値\verb|theta|を求める関数
\begin{lstlisting}
double calc_theta
  (vector<vector<double> >& x, vector<int>& y, vector<double>& alph);
\end{lstlisting}

\item 識別関数@f@（を表す@gnuplot@形式の式）、\verb|alph|、\verb|theta|を出力する関数（課題 @[1-1]@）
\begin{lstlisting}
void print_function
  (vector<vector<double> >& x, vector<int>& y, vector<double>& alph,
   double theta);
\end{lstlisting}

\item 交差検定を実施し、識別関数の精度を返す関数（課題 @[1-2]@）
\begin{lstlisting}
double cross_validation(vector<vector<double> >& x, vector<int>& y);
\end{lstlisting}

\end{itemize}

\subsection{学習データの内部形式}
与えたデータは、プログラム内で次の形で格納した。
\begin{itemize}
\item 特徴ベクトル$\bm{x}$: \verb|vector<vector<double> > x_given| に順に格納
\item クラス$y$: \verb|vector<int> y_given| に順に格納
\end{itemize}

\section{評価結果}
% \subsection{カーネルの違いによる予測精度の変化}
講義資料中の学習データ \verb|sample_linear.dat|、 \verb|sample_circle.dat| に対して、分割数$10$で交差検定を実施した結果を以下に示す。

\begin{table}
\begin{center}
\begin{tabular}{lrr}
\hline
 & sample\_linear.dat & sample\_circle.dat\\
 %% & sample$_{\text{linear}}$.dat & sample$_{\text{circle}}$.dat\\
\hline
線形カーネル & 1.00 & abort\\
多項式カーネル($d = 2$) & 0.99 & 0.96\\
多項式カーネル($d = 3$) & abort & abort\\
Gaussカーネル($\sigma = 10$) & 0.98 & 0.90\\
Gaussカーネル($\sigma = 250$) & 1.00 & 0.98\\
Gaussカーネル($\sigma = 1000$) & 1.00 & 0.75\\
\hline
\end{tabular}
\caption{@sample\_linear.dat@、 @sample\_circle.dat@ に対して、分割数$10$で交差検定}
\label{tb:first}
\end{center}
\end{table}

\begin{itemize}
\item 与えるデータ（線形分離可能なデータ、不可能なデータ）
\item カーネルの種類
\item カーネルに与えるパラメータ
\end{itemize}
によって予測精度が変化することが見てとれる。

\newpage
\subsection{Gaussカーネルのパラメータ$\sigma$の値を細かく動かす}
\verb|sample_circle.dat| に対して、Gaussカーネルのパラメータ$\sigma$を$[0,1000]$の範囲で$1$刻みで動かし、分割数$10$で交差検定を実施した結果を以下に示す。

横軸：$\sigma$、縦軸：予測精度

\begin{figure}[htbp]
  \begin{center}
    %% \includegraphics{../img/param.pdf}
  \end{center}
  \caption{\texttt{sample\_circle.dat} に対して、Gaussカーネルのパラメータ$\sigma$を動かして分割数$10$で交差検定}
  \label{fig:param}
\end{figure}

\subsection{データセットの要素数を半分にする}
さらに、\verb|sample_circle.dat| の半数（1行目から50行目まで）のデータを格納した \verb|sample_circle_half.dat| に対して、Gaussカーネルのパラメータ$\sigma$を動かして分割数$10$で交差検定を実施した結果を以下に示す。

横軸：$\sigma$、縦軸：予測精度

\begin{figure}[htbp]
  \begin{center}
    %% \includegraphics{../img/param_half.pdf}
  \end{center}
  \caption{\texttt{sample\_circle\_half.dat} に対して、Gaussカーネルのパラメータ$\sigma$を動かして分割数$10$で交差検定}
  \label{fig:param_half}
\end{figure}

\newpage
\section{考察}
\subsection{線形分離可能なデータを用いた場合と不可能なデータを用いた場合の予測精度の違い}
今回の評価の範囲では、線形分離可能なデータ（\verb|sample_linear.dat|）に対して生成した識別関数は、カーネルの種類によらず、線形分離不可能なデータ（\verb|sample_circle.dat|）に対して生成した識別関数よりも高い予測精度を示していることが分かる。（表\ref{tb:first}）

\subsection{カーネルの種類による予測精度の違い}
カーネルの種類により予測精度に違いが生じることが分かる。

多項式カーネル($d = 2$)とGaussカーネル($\sigma = 10$)は
ともに\verb|sample_circle.dat|を分離する識別関数を生成できるが、
その精度は多項式カーネル($d = 2$)を用いた場合の方が高い。（表\ref{tb:first}）

\subsection{カーネルに与えるパラメータによる予測精度の違い}
同じカーネルを用いた場合であっても、パラメータの値によって識別関数の予測精度が変わることが分かる。

\bigskip
例えば多項式カーネルを用いた場合、
$d=2$の多項式カーネルを用いたSVMで生成した識別関数は \verb|sample_linear.dat|も \verb|sample_circle.dat|も分離できているが、
$d=3$の多項式カーネルを用いたSVMでは精度以前に \verb|sample_linear.dat|に対しても \verb|sample_circle.dat|に対しても識別関数を生成することができない。（表\ref{tb:first}）

\bigskip
一方ガウスカーネルを用いた場合、
今回の評価の範囲では、パラメータ$\sigma$の値によらず \verb|sample_circle.dat| を分離できているが、その予測精度はパラメータの値によって変化することが分かる。（図\ref{fig:param}）

大域的には1カ所（$\sigma \in [190,350]$前後）に予測精度のピークが来ている。

\subsection{データ数とカーネルに与えるべきパラメータの大きさ}
さらに、同一の傾向を示すデータであっても、データ数が異なる場合適切なパラメータの値が異なることが分かる。

\verb|sample_circle.dat| の半数（1行目から50行目まで）のデータを格納した \verb|sample_circle_half.dat| に対して、Gaussカーネルのパラメータ$\sigma$を変化させると、予測精度のピークの位置が変わる（$\sigma \in [360,400]$前後）ことが分かる。（図\ref{fig:param_half}）



% \section{感想}

\section{課題}
まずは、カーネルをガウスカーネルに固定し、与えられたデータセットに対してパラメータを割り振れるような内部ルーチンを導入したい。

ただし、パラメータを細かく（$1$単位や$0.1$単位で）動かすと処理時間がかかりすぎるおそれがある。パラメータの値と予測精度の関係についてある程度の単調性を仮定し、はじめは大きな単位（例えば$100$単位）でパラメータを調整し、その後ピークが含まれていると考えられる領域に対して単位を小さくして再調整というプロセスを再帰的に繰り返し、適切なパラメータを探りたい。

ただし、とくにデータ数が少ないときは、訓練データの数が足りず
訓練データに対する過学習等が起きると考えられる。
分割数＝データ数となるよう内部で調整するなどして、できるだけ十分な交差検定を実現できるようにしたい。

\bigskip
\begin{flushright}
以上
\end{flushright}
\end{document}
