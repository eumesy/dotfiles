open Syntax

exception Error of string

let err s = raise (Error s)

(* Type Environment *)
type tyenv = ty Environment.t

let ty_prim op ty1 ty2 =
  match op with
  (* T-PLUS *)
  | Plus ->
    (match ty1, ty2 with 
    | TyInt, TyInt -> TyInt
    | _ -> err ("Argument must be of integer: +"))
      
  (* T-MULT *)
  | Mult ->
    (match ty1, ty2 with 
    | TyInt, TyInt -> TyInt
    | _ -> err ("Argument must be of integer: *"))
      
  (* T-LT *)
  | Lt ->
    (match ty1, ty2 with 
    | TyInt, TyInt -> TyBool
    | _ -> err ("Argument must be of integer: <"))
      
  (* T-AND *)
  | And ->
    (match ty1, ty2 with 
    | TyBool, TyBool -> TyBool
    | _ -> err ("Argument must be of bool: &&"))
      
  (* T-OR *)
  | Or ->
    (match ty1, ty2 with 
    | TyBool, TyBool -> TyBool
    | _ -> err ("Argument must be of bool: ||"))
;;

let rec ty_exp tyenv = function
  (* T-VAR *)
  | Var x ->
    (try Environment.lookup x tyenv with
      Environment.Not_bound -> err ("variable not bound: " ^ x))

  (* T-INT *)
  | ILit _ -> TyInt

  (* T-BOOL *)
  | BLit _ -> TyBool

  | BinOp (op, exp1, exp2) ->
    let tyarg1 = ty_exp tyenv exp1 in
    let tyarg2 = ty_exp tyenv exp2 in
    ty_prim op tyarg1 tyarg2

  (* T-IF *)
  | IfExp (exp1, exp2, exp3) ->
    let tyarg1 = ty_exp tyenv exp1 in
    let tyarg2 = ty_exp tyenv exp2 in
    let tyarg3 = ty_exp tyenv exp3 in
    if tyarg1 = TyBool && tyarg2 = tyarg3 then tyarg2
    else err ("type error: if")

  (* T-LET *)
  | LetExp (id, exp1, exp2) ->
    let tyarg1 = ty_exp tyenv exp1 in
    ty_exp (Environment.extend id tyarg1 tyenv) exp2

  | _ -> err ("Not Implemented!")
;;

let ty_decl tyenv = function
  | Exp e -> ty_exp tyenv e
  | _ -> err ("Not Implemented!")
;;
