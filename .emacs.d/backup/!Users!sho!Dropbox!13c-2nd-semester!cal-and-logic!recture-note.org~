* ??
- 前のファイルの定義が見えない
  => .vの再コンパイル

- 提出ファイルに余計なものを含めない
  - 特にフォルダに入れない
  - Makefile を入れない
    
* 2013-10-22 (追加スライド)
■場合分けの原理
P(n)を自然数nの性質について述べた命題とする

  自然数に関する場合分けの原理
  ---------------------------------
  「任意の自然数nについてP(n)」は以下と同値
  ・P(0) かつ
  ・任意の自然数n'についてP(S n')
  
・先生されるサブゴールふたつはこれらと対応
・二番目の命題は内容的に
    任意の自然数 n ≧ S O について P(n)

* 2013-11-12
- できない問題があれば、どのあたりが分からないかをコメントで残してもらえればヒント出す
- 期限までに提出してください

- 宿題のヒント(前回)
  - rev_involutive は rev と snoc に関する補題をうまく設定するのがコツです
  - bag_functions (特に member ) はちょっとトンチが効いています
    member は count をうまく使いましょう
    (ヒント：bag に要素 s が無いとき --- の値はなんでしょう？)

- 宿題のヒント(今回)
  - 前やった lists の問題を多相の問題としてやりなおしましょう
  - rev_snoc 大ヒント

* 2013-11-19
先週の宿題のヒント
- split, partition で手こずった？
- 入力リストを2回走査するのはイマイチ
- 共通点：リストのペアを返す関数
  - 再帰呼び出しの結果の活用方法が分からない?

# 2回走査しているなぁ
# 同じなんだ...

大ヒント
match l with
| nil => ???
| (a,b) :: t =>
  match split t with
    ???
  end
end.

split t は、([a2;...;],[b2;])となっている筈 # なるほど!!
これを l1, l2 でマッチすれば
# すごい very cool


partition

match l with
| nil => ???
| x :: l' => 
  match partition test l' with
    ???
  end
end.

partition test l' はどうなっているか??
ただし、課題はfilterで書け -> 2回走査するしかない?

* 2013-11-16 (length_snoc)
length_snoc'

case
  intros n eq. (simpl.) rewrite <- eq. reflexivity.
case
  (nは0じゃなさそう…。lはconsなんだし)
  intros n eq. simpl. destruct n as [|n'] (場合分けしよう)
    scase
      inversion eq.
    scase
      apply f_equal. apply IHL'. inversion eq.(仮定の左辺はcoqが計算してる) reflexivety. Qed.
            -------
            inversionじゃいけないの??
            
---
forall n が残っている段階でinductionした
===> 「帰納法の仮定を変える」話
* 2013-12-03
- destruct eqnが使えない? ---> Coq 8.4(以後)を使ってください

- ∀n.∀m. double n = double m -> n = m
  ∀n.∀m. n + n = m + m -> n = m (宿題)

  コツ ===>
  ∀n.『∀m. double n = double m -> n = m』
  ∀n.『∀m. n + n = m + m -> n = m』
  ここを帰納法のP(n)として証明する (mをintrosしない)

  なぜ?
  nだけ増やしてもだめ。nとmがいっぺんに増えるとうまくいく
  
  a,b:nat
  double a = double b -> a = b ならば
  double (S a) = double b -> S a = b // これだとよく分からない
  
  a,b:nat
  double a = double b -> a = b ならば
  double (S a) = double (S b) -> S a = S b // これだとうまくいきそう
  ---------------------------
  S(S(double a)) = S(S(double b)) // こうなってしまえばSを外せばOK


  何をしている? // ここ分からない…
  a:nat として、∀m. a+a = m+m -> a=m
                     ----------------
                     P(a,m)
  (a,0),   (a,1),   (a,2)   ... に対してPが成立する
       \
        \
	 \
	  \
  (a+1,0), (a+1,1), (a+1,2) ... に対してPが成立する
  - 両方減らしたペアが帰納法の仮定に入っている
  - (a+1,0)はあり得ない

* 2013-12-17
and_commut


Proof.
  intros P Q H.
  destruct H as [HP HQ].
  split. (* apply conj *) coqはandを知っているので
    apply HP.
    apply QP.
  Qed.


Proof.or_distributes_over_and_1
  intros
  destruct as [HP |  HQR].

  ...
  Case "right".
    destruct HQR as [HQ HR].
    split.
    ...

and_true_intro

Proof
  intros
  destruct H as [Hb Hc].
  rewrite Hb. rewrite Hc. reflexivity...

andb_prop

Proof.
  intros
  destruct b.

どちらかfalseなら矛盾->なんでも言える
両方trueなら結論がほとんど自明

* 2014-01-07
ev__even'

intros n E. induction n as [| n'].
Case "n = 0".
  unfold even. reflexivity.
Case "n = S n'"
  unfold even. simpl.
(* ここで手詰まり 1つ小さい数は奇数 帰納法の仮定がうまく使えない *)

2n is beautiful
  2n = n + n


