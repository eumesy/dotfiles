#include <iostream>
#include <string>
#include <vector>
#include <algorithm> // std::max
#include <limits> // std::numeric_limits

#include "pair_align.hh"
#include "phylogenetic_tree.hh"

using namespace std;

int main(void) {
  // sequences
  vector<string> seq;
  seq.push_back("CCAGAT");
  seq.push_back("ACCGA");
  seq.push_back("ACGAT");
  seq.push_back("CGAAT");

  const int num_of_seq = (int)(seq.size());
  // print sequences
  for (int i=0; i<num_of_seq; i++)
	cout << i << ": " << seq[i] << endl;
  cout << endl;

  int seq_len_max = 0;
  for (int i=0; i<num_of_seq; i++)
	seq_len_max = max(seq_len_max, (int)(seq[i].size()));

  // 各配列間でグローバルアラインメントを行うことで類似度を算出
  vector<vector<int> > similarity(num_of_seq, vector<int>(num_of_seq));
  int similarity_min = std::numeric_limits<int>::max();
  //  string dummy_str1, dummy_str2;
  for (int i=0; i<num_of_seq; i++) {
	for (int j=0; j<num_of_seq; j++) {
	  if (j == i) // 同一配列同士の類似度は不要
		continue;
	  else if (j > i) {
		// global alignment を用いて類似度算出
		similarity[i][j] = similarity_with_glob_align(seq[i], seq[j]);
		similarity_min = std::min(similarity_min, similarity[i][j]);
	  }
	  else // j < i
		similarity[i][j] = similarity[j][i];
	}
  }
  // print similarity
  for (int i=0; i<num_of_seq; i++)
	for (int j=i+1; j<num_of_seq; j++)
	  cout << "similarity[" << i << "][" << j << "]: " << similarity[i][j] << endl;
  cout << endl;

  // 配列間類似度を配列間距離に変換
  const int similarity_max_theorical = Score::same * seq_len_max;
  int similarity_range;
  similarity_range = similarity_max_theorical - similarity_min;
  vector<vector<double> > distance(num_of_seq, vector<double>(num_of_seq));
  for (int i=0; i<num_of_seq; i++) {
	for (int j=0; j<num_of_seq; j++) {
	  if (j == i)
		continue;
	  else if (j > i) // 正規化
		distance[i][j] = 1.0 - ((similarity[i][j] - similarity_min) / (double)similarity_range);
	  else // j < i
		distance[i][j] = distance[j][i];
	}
  }
  // print distance
  for (int i=0; i<num_of_seq; i++)
	for (int j=i+1; j<num_of_seq; j++)
	  cout << "distance[" << i << "][" << j << "]: " << distance[i][j] << endl;
  cout << endl;
  
  // 配列間距離に基づき近隣結合法で案内木作成
  vector<tree_node> guide_tree = make_guide_tree(seq, distance);

  
  // 近隣結合法で生成した中間ノードの1番目
  vector<tree_node>::iterator the_first_intermediate_node = guide_tree.begin() + num_of_seq;
  // 案内木に基づいて配列アラインメントを実施
  for (vector<tree_node>::iterator n = the_first_intermediate_node; n != guide_tree.end(); n++) {
	tree_node* fst_child = &(guide_tree[(*n).fst_child_index]);
	tree_node* snd_child = &(guide_tree[(*n).snd_child_index]);
	// 中間ノードひとつ分のアラインメント
	(*n).profile = global_alignment(fst_child->profile,	snd_child->profile);

	// 結果出力
	cout << fst_child->node_index << ": ";
	for (int i=0; i<fst_child->profile.size(); i++) {
	  if (i != 0 )
		cout << "   ";
	  cout << fst_child->profile[i] << endl;
	}
	cout << snd_child->node_index << ": ";
	for (int i=0; i<snd_child->profile.size(); i++) {
	  if (i != 0 )
		cout << "   ";
	  cout << snd_child->profile[i] << endl;
	}
	cout << "==>" << endl;
	cout << (*n).node_index << ": ";
	for (int i=0; i<(*n).profile.size(); i++) {
	  if (i != 0 )
		cout << "   ";
	  cout << (*n).profile[i] << endl;
	}
	cout << endl;
  }
  
  return 0;
}
